<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CVL: cvl/cvl_filter.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>cvl/cvl_filter.h File Reference</h1>Filtering frames. <a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#36c8c71be513e1ecbabd011921b497c1">cvl_convolve</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *src, const float *kernel, int h_len, int v_len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#a8a9629b8af4b4815fd24ac6d95f7762">cvl_convolve_separable</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *src, const float *h, int h_len, const float *v, int v_len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#8dfd9a499529a80d044cd0212d43412e">cvl_convolve3d</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **srcs, const float *kernel, int h_len, int v_len, int t_len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#122994196e48bd50b47f24e5e7ea9325">cvl_convolve3d_separable</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **srcs, const float *h, int h_len, const float *v, int v_len, const float *t, int t_len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#a4b542a2c96d1f75f8cca5786eb0ae1d">cvl_mean</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *src, int k_h, int k_v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#9c59773ab8b5c04da78c40c757bc4883">cvl_mean3d</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **srcs, int k_h, int k_v, int k_t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#fcf2f3cbe6ea0adf79f850cb7d7dd8f3">cvl_gauss_k_to_sigma</a> (int k)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#22a38e7dc08b680a1ba870db3430cb1c">cvl_gauss_sigma_to_k</a> (float sigma)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#282fb80ff2a9dea1e709de2b97526464">cvl_gauss</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *src, int k_h, int k_v, float sigma_h, float sigma_v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#f0904d465d10fd5cf6aec3b52e614e91">cvl_gauss3d</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **srcs, int k_h, int k_v, int k_t, float sigma_h, float sigma_v, float sigma_t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#ff0308c4b6b374530b5313c6d3e05464">cvl_min</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *src, int k_h, int k_v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#43fdac88bed41c4318fa01fbfdf9f99c">cvl_min3d</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **srcs, int k_h, int k_v, int k_t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#6f859e7f8dd17026a82e81fb9cdc3ac8">cvl_max</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *src, int k_h, int k_v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#bb245e605f04fc2ab65a8f65e4b738e3">cvl_max3d</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **srcs, int k_h, int k_v, int k_t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#9e7006b9d3cc27ec80b10266257f1c7a">cvl_median</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *src, int k_h, int k_v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#66da7066e995dcb2599cec90419ebf0d">cvl_median3d</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **srcs, int k_h, int k_v, int k_t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#c4f048cc2b1866453be249b752739411">cvl_median_separated</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *src, int k_h, int k_v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#1f3a400b3e1babaa2ec62e7cbfc8cff3">cvl_median3d_separated</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **srcs, int k_h, int k_v, int k_t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#f91ecd4da693e5d70f465603065c3ad4">cvl_laplace</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *src, float c)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#b9c6e1343023c28b086a483e7b77e129">cvl_unsharpmask</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *src, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *smoothed, float c)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Filtering frames. 
<p>
Filtering frames. <hr><h2>Function Documentation</h2>
<a class="anchor" name="36c8c71be513e1ecbabd011921b497c1"></a><!-- doxytag: member="cvl_filter.h::cvl_convolve" ref="36c8c71be513e1ecbabd011921b497c1" args="(cvl_frame_t *dst, cvl_frame_t *src, const float *kernel, int h_len, int v_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_convolve           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>h_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kernel</em>&nbsp;</td><td>The convolution kernel as an array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h_len</em>&nbsp;</td><td>Number of columns of the kernel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v_len</em>&nbsp;</td><td>Number of rows of the kernel.</td></tr>
  </table>
</dl>
Applies a convolution kernel to a frame. Both <em>h_len</em> and <em>v_len</em> must be odd. 
</div>
</div><p>
<a class="anchor" name="a8a9629b8af4b4815fd24ac6d95f7762"></a><!-- doxytag: member="cvl_filter.h::cvl_convolve_separable" ref="a8a9629b8af4b4815fd24ac6d95f7762" args="(cvl_frame_t *dst, cvl_frame_t *src, const float *h, int h_len, const float *v, int v_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_convolve_separable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>h_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>The horizontal part of the separable convolution matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h_len</em>&nbsp;</td><td>The length of the horizontal part. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The vertical part of the separable convolution matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v_len</em>&nbsp;</td><td>The length of the vertical part.</td></tr>
  </table>
</dl>
Applies a separable convolution matrix to a frame. Both <em>h_len</em> and <em>v_len</em> must be odd numbers. 
</div>
</div><p>
<a class="anchor" name="8dfd9a499529a80d044cd0212d43412e"></a><!-- doxytag: member="cvl_filter.h::cvl_convolve3d" ref="8dfd9a499529a80d044cd0212d43412e" args="(cvl_frame_t *dst, cvl_frame_t **srcs, const float *kernel, int h_len, int v_len, int t_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_convolve3d           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **&nbsp;</td>
          <td class="paramname"> <em>srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>h_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>t_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcs</em>&nbsp;</td><td>The source frames. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kernel</em>&nbsp;</td><td>The convolution kernel as an array of ints. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h_len</em>&nbsp;</td><td>Dimension in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v_len</em>&nbsp;</td><td>Dimension in vertical direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t_len</em>&nbsp;</td><td>Dimension in temporal direction.</td></tr>
  </table>
</dl>
Applies a 3D convolution matrix on a frame. The number of frames in the array <em>srcs</em> must be <em>t_len</em>. Only the entry at (<em>t_len</em> / 2) must be non-NULL, because this is the frame that will be processed. The number of past and future frames (those with indices less than or greater than <em>t_len</em> / 2) can be limited; in this case, some array entries can be NULL. This function will use clamping in the t direction to compensate that. The dimensions <em>h_len</em>, <em>v_len</em>, <em>t_len</em> must all be odd. 
</div>
</div><p>
<a class="anchor" name="122994196e48bd50b47f24e5e7ea9325"></a><!-- doxytag: member="cvl_filter.h::cvl_convolve3d_separable" ref="122994196e48bd50b47f24e5e7ea9325" args="(cvl_frame_t *dst, cvl_frame_t **srcs, const float *h, int h_len, const float *v, int v_len, const float *t, int t_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_convolve3d_separable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **&nbsp;</td>
          <td class="paramname"> <em>srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>h_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>t_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcs</em>&nbsp;</td><td>The source frames. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>The horizontal part of the separable convolution kernel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h_len</em>&nbsp;</td><td>The length of the horizontal part. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The vertical part of the separable convolution kernel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v_len</em>&nbsp;</td><td>The length of the vertical part. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The temporal part of the separable convolution matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t_len</em>&nbsp;</td><td>The length of the temporal part.</td></tr>
  </table>
</dl>
Applies a separable 3D convolution matrix on a frame. The number of frames in the array <em>srcs</em> must be <em>t_len</em>. Only the entry at (<em>t_len</em> / 2) must be non-NULL, because this is the frame that will be processed. The number of past and future frames (those with indices less than or greater than <em>t_len</em> / 2) can be limited; in this case, some array entries can be NULL. This function will use clamping in the t direction to compensate that. The dimensions <em>h_len</em>, <em>v_len</em>, <em>t_len</em> must all be odd. 
</div>
</div><p>
<a class="anchor" name="a4b542a2c96d1f75f8cca5786eb0ae1d"></a><!-- doxytag: member="cvl_filter.h::cvl_mean" ref="a4b542a2c96d1f75f8cca5786eb0ae1d" args="(cvl_frame_t *dst, cvl_frame_t *src, int k_h, int k_v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_mean           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction.</td></tr>
  </table>
</dl>
Applies Mean filtering to a frame. The number of matrix columns will be 2k_h+1, the number of rows will be 2k_v+1. 
</div>
</div><p>
<a class="anchor" name="9c59773ab8b5c04da78c40c757bc4883"></a><!-- doxytag: member="cvl_filter.h::cvl_mean3d" ref="9c59773ab8b5c04da78c40c757bc4883" args="(cvl_frame_t *dst, cvl_frame_t **srcs, int k_h, int k_v, int k_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_mean3d           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **&nbsp;</td>
          <td class="paramname"> <em>srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcs</em>&nbsp;</td><td>The source frames. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_t</em>&nbsp;</td><td>Mask size in temporal direction.</td></tr>
  </table>
</dl>
Applies Mean filtering. See <a class="el" href="cvl__filter_8h.html#122994196e48bd50b47f24e5e7ea9325">cvl_convolve3d_separable()</a> for a description of <em>srcs</em>. The kernel size will be (2k_t+1)x(2k_v+1)x(2k_h+1). 
</div>
</div><p>
<a class="anchor" name="fcf2f3cbe6ea0adf79f850cb7d7dd8f3"></a><!-- doxytag: member="cvl_filter.h::cvl_gauss_k_to_sigma" ref="fcf2f3cbe6ea0adf79f850cb7d7dd8f3" args="(int k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float cvl_gauss_k_to_sigma           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>The parameter k of <a class="el" href="cvl__filter_8h.html#282fb80ff2a9dea1e709de2b97526464">cvl_gauss()</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sigma.</dd></dl>
Computes a sigma value that matches the given <em>k:</em> roughly 95% of the mass should lie within the mask. 
</div>
</div><p>
<a class="anchor" name="22a38e7dc08b680a1ba870db3430cb1c"></a><!-- doxytag: member="cvl_filter.h::cvl_gauss_sigma_to_k" ref="22a38e7dc08b680a1ba870db3430cb1c" args="(float sigma)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvl_gauss_sigma_to_k           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sigma</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sigma</em>&nbsp;</td><td>The parameter sigma of <a class="el" href="cvl__filter_8h.html#282fb80ff2a9dea1e709de2b97526464">cvl_gauss()</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>k.</dd></dl>
Computes a k value that matches the given <em>sigma:</em> roughly 95% of the mass should lie within the mask. 
</div>
</div><p>
<a class="anchor" name="282fb80ff2a9dea1e709de2b97526464"></a><!-- doxytag: member="cvl_filter.h::cvl_gauss" ref="282fb80ff2a9dea1e709de2b97526464" args="(cvl_frame_t *dst, cvl_frame_t *src, int k_h, int k_v, float sigma_h, float sigma_v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_gauss           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sigma_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sigma_v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sigma_h</em>&nbsp;</td><td>Sigma value in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sigma_v</em>&nbsp;</td><td>Sigma value in vertical direction.</td></tr>
  </table>
</dl>
Applies Gauss filtering to a frame. The number of matrix columns will be 2k_h+1, the number of rows will be 2k_v+1. See also <a class="el" href="cvl__filter_8h.html#fcf2f3cbe6ea0adf79f850cb7d7dd8f3">cvl_gauss_k_to_sigma()</a> and <a class="el" href="cvl__filter_8h.html#22a38e7dc08b680a1ba870db3430cb1c">cvl_gauss_sigma_to_k()</a>. 
</div>
</div><p>
<a class="anchor" name="f0904d465d10fd5cf6aec3b52e614e91"></a><!-- doxytag: member="cvl_filter.h::cvl_gauss3d" ref="f0904d465d10fd5cf6aec3b52e614e91" args="(cvl_frame_t *dst, cvl_frame_t **srcs, int k_h, int k_v, int k_t, float sigma_h, float sigma_v, float sigma_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_gauss3d           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **&nbsp;</td>
          <td class="paramname"> <em>srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sigma_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sigma_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sigma_t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcs</em>&nbsp;</td><td>The source frames. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_t</em>&nbsp;</td><td>Mask size in temporal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sigma_h</em>&nbsp;</td><td>Sigma value in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sigma_v</em>&nbsp;</td><td>Sigma value in vertical direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sigma_t</em>&nbsp;</td><td>Sigma value in temporal direction.</td></tr>
  </table>
</dl>
Applies Gauss filtering. See <a class="el" href="cvl__filter_8h.html#122994196e48bd50b47f24e5e7ea9325">cvl_convolve3d_separable()</a> for a description of <em>frames</em>. The kernel size will be (2k_t+1)x(2k_v+1)x(2k_h+1). See also <a class="el" href="cvl__filter_8h.html#fcf2f3cbe6ea0adf79f850cb7d7dd8f3">cvl_gauss_k_to_sigma()</a> and <a class="el" href="cvl__filter_8h.html#22a38e7dc08b680a1ba870db3430cb1c">cvl_gauss_sigma_to_k()</a>. 
</div>
</div><p>
<a class="anchor" name="ff0308c4b6b374530b5313c6d3e05464"></a><!-- doxytag: member="cvl_filter.h::cvl_min" ref="ff0308c4b6b374530b5313c6d3e05464" args="(cvl_frame_t *dst, cvl_frame_t *src, int k_h, int k_v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_min           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction.</td></tr>
  </table>
</dl>
Applies Minimum filtering to a frame. The number of matrix columns will be 2k_h+1, the number of rows will be 2k_v+1. 
</div>
</div><p>
<a class="anchor" name="43fdac88bed41c4318fa01fbfdf9f99c"></a><!-- doxytag: member="cvl_filter.h::cvl_min3d" ref="43fdac88bed41c4318fa01fbfdf9f99c" args="(cvl_frame_t *dst, cvl_frame_t **srcs, int k_h, int k_v, int k_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_min3d           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **&nbsp;</td>
          <td class="paramname"> <em>srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcs</em>&nbsp;</td><td>The source frames. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_t</em>&nbsp;</td><td>Mask size in temporal direction.</td></tr>
  </table>
</dl>
Applies Minimum filtering. See <a class="el" href="cvl__filter_8h.html#122994196e48bd50b47f24e5e7ea9325">cvl_convolve3d_separable()</a> for a description of <em>frames</em>. The kernel size will be (2k_t+1)x(2k_v+1)x(2k_h+1). 
</div>
</div><p>
<a class="anchor" name="6f859e7f8dd17026a82e81fb9cdc3ac8"></a><!-- doxytag: member="cvl_filter.h::cvl_max" ref="6f859e7f8dd17026a82e81fb9cdc3ac8" args="(cvl_frame_t *dst, cvl_frame_t *src, int k_h, int k_v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_max           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction.</td></tr>
  </table>
</dl>
Applies Maximum filtering to a frame. The number of matrix columns will be 2k_h+1, the number of rows will be 2k_v+1. 
</div>
</div><p>
<a class="anchor" name="bb245e605f04fc2ab65a8f65e4b738e3"></a><!-- doxytag: member="cvl_filter.h::cvl_max3d" ref="bb245e605f04fc2ab65a8f65e4b738e3" args="(cvl_frame_t *dst, cvl_frame_t **srcs, int k_h, int k_v, int k_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_max3d           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **&nbsp;</td>
          <td class="paramname"> <em>srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcs</em>&nbsp;</td><td>The source frames. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_t</em>&nbsp;</td><td>Mask size in temporal direction.</td></tr>
  </table>
</dl>
Applies Maximum filtering. See <a class="el" href="cvl__filter_8h.html#122994196e48bd50b47f24e5e7ea9325">cvl_convolve3d_separable()</a> for a description of <em>frames</em>. The kernel size will be (2k_t+1)x(2k_v+1)x(2k_h+1). 
</div>
</div><p>
<a class="anchor" name="9e7006b9d3cc27ec80b10266257f1c7a"></a><!-- doxytag: member="cvl_filter.h::cvl_median" ref="9e7006b9d3cc27ec80b10266257f1c7a" args="(cvl_frame_t *dst, cvl_frame_t *src, int k_h, int k_v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_median           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction.</td></tr>
  </table>
</dl>
Applies Median filtering to a frame. The number of matrix columns will be 2k_h+1, the number of rows will be 2k_v+1. 
</div>
</div><p>
<a class="anchor" name="66da7066e995dcb2599cec90419ebf0d"></a><!-- doxytag: member="cvl_filter.h::cvl_median3d" ref="66da7066e995dcb2599cec90419ebf0d" args="(cvl_frame_t *dst, cvl_frame_t **srcs, int k_h, int k_v, int k_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_median3d           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **&nbsp;</td>
          <td class="paramname"> <em>srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcs</em>&nbsp;</td><td>The source frames. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_t</em>&nbsp;</td><td>Mask size in temporal direction.</td></tr>
  </table>
</dl>
Applies Median filtering. See <a class="el" href="cvl__filter_8h.html#122994196e48bd50b47f24e5e7ea9325">cvl_convolve3d_separable()</a> for a description of <em>frames</em>. The kernel size will be (2k_t+1)x(2k_v+1)x(2k_h+1). 
</div>
</div><p>
<a class="anchor" name="c4f048cc2b1866453be249b752739411"></a><!-- doxytag: member="cvl_filter.h::cvl_median_separated" ref="c4f048cc2b1866453be249b752739411" args="(cvl_frame_t *dst, cvl_frame_t *src, int k_h, int k_v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_median_separated           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction.</td></tr>
  </table>
</dl>
Applies approximated Median filtering to a frame. The Median filter is separated for this purpose. The results are usually close to the real median filter results. The number of matrix columns will be 2k_h+1, the number of rows will be 2k_v+1. 
</div>
</div><p>
<a class="anchor" name="1f3a400b3e1babaa2ec62e7cbfc8cff3"></a><!-- doxytag: member="cvl_filter.h::cvl_median3d_separated" ref="1f3a400b3e1babaa2ec62e7cbfc8cff3" args="(cvl_frame_t *dst, cvl_frame_t **srcs, int k_h, int k_v, int k_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_median3d_separated           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **&nbsp;</td>
          <td class="paramname"> <em>srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcs</em>&nbsp;</td><td>The source frames. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_t</em>&nbsp;</td><td>Mask size in temporal direction.</td></tr>
  </table>
</dl>
Applies approximated Median filtering. The Median filter is separated for this purpose. The results are usually close to the real median filter results. See <a class="el" href="cvl__filter_8h.html#122994196e48bd50b47f24e5e7ea9325">cvl_convolve3d_separable()</a> for a description of <em>frames</em>. The kernel size will be (2k_t+1)x(2k_v+1)x(2k_h+1). 
</div>
</div><p>
<a class="anchor" name="f91ecd4da693e5d70f465603065c3ad4"></a><!-- doxytag: member="cvl_filter.h::cvl_laplace" ref="f91ecd4da693e5d70f465603065c3ad4" args="(cvl_frame_t *dst, cvl_frame_t *src, float c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_laplace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The sharpness parameter, greater than or equal to zero.</td></tr>
  </table>
</dl>
Sharpens a frame with the Laplacian operator. The parameter <em>c</em> determines the strength of the sharpening effect. This function works best on frames in <a class="el" href="cvl__frame_8h.html#d52f0a17a1c8313b764cf8a44736f33d2f2614697f0f2cef2cc0259ca451fde5">CVL_XYZ</a> format. 
</div>
</div><p>
<a class="anchor" name="b9c6e1343023c28b086a483e7b77e129"></a><!-- doxytag: member="cvl_filter.h::cvl_unsharpmask" ref="b9c6e1343023c28b086a483e7b77e129" args="(cvl_frame_t *dst, cvl_frame_t *src, cvl_frame_t *smoothed, float c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_unsharpmask           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>smoothed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>smoothed</em>&nbsp;</td><td>A smoothed version of the frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The sharpness parameter, from (0.5, 1.0).</td></tr>
  </table>
</dl>
Sharpens the a frame using unsharp masking. The frame <em>smoothed</em> must be a smoothed version of <em>src</em>, for example produced by 3x3 Gauss filtering. The parameter <em>c</em> determines the strength of the sharpening effect. This function works best on frames in <a class="el" href="cvl__frame_8h.html#d52f0a17a1c8313b764cf8a44736f33d2f2614697f0f2cef2cc0259ca451fde5">CVL_XYZ</a> format. 
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Sun Jul 27 13:48:14 2008 for CVL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
