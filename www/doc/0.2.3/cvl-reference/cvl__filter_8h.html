<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CVL: cvl/cvl_filter.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>cvl/cvl_filter.h File Reference</h1>Filtering frames. <a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#8964fa018da19cd07e2c340fb7a746a6">cvl_convolve</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *src, const float *kernel, int h_len, int v_len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#71ee44104ace68734127ed1dda793b55">cvl_convolve_separable</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *src, const float *h, int h_len, const float *v, int v_len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#183e5c17fde8044939eb11e01689cc6d">cvl_convolve3d</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **srcs, const float *kernel, int h_len, int v_len, int t_len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#9ddf0662c68bfcebbc38543cd8be8fe4">cvl_convolve3d_separable</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **srcs, const float *h, int h_len, const float *v, int v_len, const float *t, int t_len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#87846ad5358ba9c2d7f9c2ddb0591f20">cvl_mean</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *src, int k_h, int k_v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#d50099390d4a7b560539429bd185031e">cvl_mean3d</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **srcs, int k_h, int k_v, int k_t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#a84447301f1b3e0d281948ebf3b7b1a4">cvl_gauss_k_to_sigma</a> (int k)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#4f2242dcfe9ae685ac97365644801e07">cvl_gauss_sigma_to_k</a> (float sigma)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#fd5f188658c736e277075ae152ce8ab4">cvl_gauss</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *src, int k_h, int k_v, float sigma_h, float sigma_v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#ad240c5fe2000879d4bd03eecb3a7c42">cvl_gauss3d</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **srcs, int k_h, int k_v, int k_t, float sigma_h, float sigma_v, float sigma_t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#65696a20455019b05162fa1eff2ac486">cvl_min</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *src, int k_h, int k_v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#2ff684e67cfebfc8c9563e6154ad74b9">cvl_min3d</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **srcs, int k_h, int k_v, int k_t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#cb49b2e6231b99254c7258575c0cedeb">cvl_max</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *src, int k_h, int k_v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#6d4ecd79a80c1c9a4660a0bd54316c29">cvl_max3d</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **srcs, int k_h, int k_v, int k_t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#f3a7af61d9fb85e028f18006879c8951">cvl_median</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *src, int k_h, int k_v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#f9f8e377d7f4c2f69cdf6e2e0cf5cec4">cvl_median3d</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **srcs, int k_h, int k_v, int k_t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#e91bb38635992a557efabc4923494a98">cvl_median_separated</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *src, int k_h, int k_v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#037430b75e1c4f741411a2aa88d84f48">cvl_median3d_separated</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **srcs, int k_h, int k_v, int k_t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#9937e892e33fe1a6fabc3104e6ce973d">cvl_laplace</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *src, float c)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvl__filter_8h.html#dee615707fccb7ec6e79f6dd46fd37af">cvl_unsharpmask</a> (<a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *dst, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *src, <a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *smoothed, float c)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Filtering frames. <hr><h2>Function Documentation</h2>
<a class="anchor" name="8964fa018da19cd07e2c340fb7a746a6"></a><!-- doxytag: member="cvl_filter.h::cvl_convolve" ref="8964fa018da19cd07e2c340fb7a746a6" args="(cvl_frame_t *dst, cvl_frame_t *src, const float *kernel, int h_len, int v_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_convolve           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>h_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kernel</em>&nbsp;</td><td>The convolution kernel as an array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h_len</em>&nbsp;</td><td>Number of columns of the kernel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v_len</em>&nbsp;</td><td>Number of rows of the kernel.</td></tr>
  </table>
</dl>
Applies a convolution kernel to a frame. Both <em>h_len</em> and <em>v_len</em> must be odd. 
</div>
</div><p>
<a class="anchor" name="71ee44104ace68734127ed1dda793b55"></a><!-- doxytag: member="cvl_filter.h::cvl_convolve_separable" ref="71ee44104ace68734127ed1dda793b55" args="(cvl_frame_t *dst, cvl_frame_t *src, const float *h, int h_len, const float *v, int v_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_convolve_separable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>h_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>The horizontal part of the separable convolution matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h_len</em>&nbsp;</td><td>The length of the horizontal part. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The vertical part of the separable convolution matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v_len</em>&nbsp;</td><td>The length of the vertical part.</td></tr>
  </table>
</dl>
Applies a separable convolution matrix to a frame. Both <em>h_len</em> and <em>v_len</em> must be odd numbers. 
</div>
</div><p>
<a class="anchor" name="183e5c17fde8044939eb11e01689cc6d"></a><!-- doxytag: member="cvl_filter.h::cvl_convolve3d" ref="183e5c17fde8044939eb11e01689cc6d" args="(cvl_frame_t *dst, cvl_frame_t **srcs, const float *kernel, int h_len, int v_len, int t_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_convolve3d           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **&nbsp;</td>
          <td class="paramname"> <em>srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>h_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>t_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcs</em>&nbsp;</td><td>The source frames. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kernel</em>&nbsp;</td><td>The convolution kernel as an array of ints. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h_len</em>&nbsp;</td><td>Dimension in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v_len</em>&nbsp;</td><td>Dimension in vertical direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t_len</em>&nbsp;</td><td>Dimension in temporal direction.</td></tr>
  </table>
</dl>
Applies a 3D convolution matrix on a frame. The number of frames in the array <em>srcs</em> must be <em>t_len</em>. Only the entry at (<em>t_len</em> / 2) must be non-NULL, because this is the frame that will be processed. The number of past and future frames (those with indices less than or greater than <em>t_len</em> / 2) can be limited; in this case, some array entries can be NULL. This function will use clamping in the t direction to compensate that. The dimensions <em>h_len</em>, <em>v_len</em>, <em>t_len</em> must all be odd. 
</div>
</div><p>
<a class="anchor" name="9ddf0662c68bfcebbc38543cd8be8fe4"></a><!-- doxytag: member="cvl_filter.h::cvl_convolve3d_separable" ref="9ddf0662c68bfcebbc38543cd8be8fe4" args="(cvl_frame_t *dst, cvl_frame_t **srcs, const float *h, int h_len, const float *v, int v_len, const float *t, int t_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_convolve3d_separable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **&nbsp;</td>
          <td class="paramname"> <em>srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>h_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>t_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcs</em>&nbsp;</td><td>The source frames. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>The horizontal part of the separable convolution kernel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h_len</em>&nbsp;</td><td>The length of the horizontal part. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The vertical part of the separable convolution kernel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v_len</em>&nbsp;</td><td>The length of the vertical part. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The temporal part of the separable convolution matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t_len</em>&nbsp;</td><td>The length of the temporal part.</td></tr>
  </table>
</dl>
Applies a separable 3D convolution matrix on a frame. The number of frames in the array <em>srcs</em> must be <em>t_len</em>. Only the entry at (<em>t_len</em> / 2) must be non-NULL, because this is the frame that will be processed. The number of past and future frames (those with indices less than or greater than <em>t_len</em> / 2) can be limited; in this case, some array entries can be NULL. This function will use clamping in the t direction to compensate that. The dimensions <em>h_len</em>, <em>v_len</em>, <em>t_len</em> must all be odd. 
</div>
</div><p>
<a class="anchor" name="87846ad5358ba9c2d7f9c2ddb0591f20"></a><!-- doxytag: member="cvl_filter.h::cvl_mean" ref="87846ad5358ba9c2d7f9c2ddb0591f20" args="(cvl_frame_t *dst, cvl_frame_t *src, int k_h, int k_v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_mean           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction.</td></tr>
  </table>
</dl>
Applies Mean filtering to a frame. The number of matrix columns will be 2k_h+1, the number of rows will be 2k_v+1. 
</div>
</div><p>
<a class="anchor" name="d50099390d4a7b560539429bd185031e"></a><!-- doxytag: member="cvl_filter.h::cvl_mean3d" ref="d50099390d4a7b560539429bd185031e" args="(cvl_frame_t *dst, cvl_frame_t **srcs, int k_h, int k_v, int k_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_mean3d           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **&nbsp;</td>
          <td class="paramname"> <em>srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcs</em>&nbsp;</td><td>The source frames. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_t</em>&nbsp;</td><td>Mask size in temporal direction.</td></tr>
  </table>
</dl>
Applies Mean filtering. See <a class="el" href="cvl__filter_8h.html#9ddf0662c68bfcebbc38543cd8be8fe4">cvl_convolve3d_separable()</a> for a description of <em>srcs</em>. The kernel size will be (2k_t+1)x(2k_v+1)x(2k_h+1). 
</div>
</div><p>
<a class="anchor" name="a84447301f1b3e0d281948ebf3b7b1a4"></a><!-- doxytag: member="cvl_filter.h::cvl_gauss_k_to_sigma" ref="a84447301f1b3e0d281948ebf3b7b1a4" args="(int k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float cvl_gauss_k_to_sigma           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>The parameter k of <a class="el" href="cvl__filter_8h.html#fd5f188658c736e277075ae152ce8ab4">cvl_gauss()</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sigma.</dd></dl>
Computes a sigma value that matches the given <em>k:</em> roughly 95% of the mass should lie within the mask. 
</div>
</div><p>
<a class="anchor" name="4f2242dcfe9ae685ac97365644801e07"></a><!-- doxytag: member="cvl_filter.h::cvl_gauss_sigma_to_k" ref="4f2242dcfe9ae685ac97365644801e07" args="(float sigma)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvl_gauss_sigma_to_k           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sigma</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sigma</em>&nbsp;</td><td>The parameter sigma of <a class="el" href="cvl__filter_8h.html#fd5f188658c736e277075ae152ce8ab4">cvl_gauss()</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>k.</dd></dl>
Computes a k value that matches the given <em>sigma:</em> roughly 95% of the mass should lie within the mask. 
</div>
</div><p>
<a class="anchor" name="fd5f188658c736e277075ae152ce8ab4"></a><!-- doxytag: member="cvl_filter.h::cvl_gauss" ref="fd5f188658c736e277075ae152ce8ab4" args="(cvl_frame_t *dst, cvl_frame_t *src, int k_h, int k_v, float sigma_h, float sigma_v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_gauss           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sigma_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sigma_v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sigma_h</em>&nbsp;</td><td>Sigma value in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sigma_v</em>&nbsp;</td><td>Sigma value in vertical direction.</td></tr>
  </table>
</dl>
Applies Gauss filtering to a frame. The number of matrix columns will be 2k_h+1, the number of rows will be 2k_v+1. See also <a class="el" href="cvl__filter_8h.html#a84447301f1b3e0d281948ebf3b7b1a4">cvl_gauss_k_to_sigma()</a> and <a class="el" href="cvl__filter_8h.html#4f2242dcfe9ae685ac97365644801e07">cvl_gauss_sigma_to_k()</a>. 
</div>
</div><p>
<a class="anchor" name="ad240c5fe2000879d4bd03eecb3a7c42"></a><!-- doxytag: member="cvl_filter.h::cvl_gauss3d" ref="ad240c5fe2000879d4bd03eecb3a7c42" args="(cvl_frame_t *dst, cvl_frame_t **srcs, int k_h, int k_v, int k_t, float sigma_h, float sigma_v, float sigma_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_gauss3d           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **&nbsp;</td>
          <td class="paramname"> <em>srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sigma_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sigma_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sigma_t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcs</em>&nbsp;</td><td>The source frames. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_t</em>&nbsp;</td><td>Mask size in temporal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sigma_h</em>&nbsp;</td><td>Sigma value in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sigma_v</em>&nbsp;</td><td>Sigma value in vertical direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sigma_t</em>&nbsp;</td><td>Sigma value in temporal direction.</td></tr>
  </table>
</dl>
Applies Gauss filtering. See <a class="el" href="cvl__filter_8h.html#9ddf0662c68bfcebbc38543cd8be8fe4">cvl_convolve3d_separable()</a> for a description of <em>frames</em>. The kernel size will be (2k_t+1)x(2k_v+1)x(2k_h+1). See also <a class="el" href="cvl__filter_8h.html#a84447301f1b3e0d281948ebf3b7b1a4">cvl_gauss_k_to_sigma()</a> and <a class="el" href="cvl__filter_8h.html#4f2242dcfe9ae685ac97365644801e07">cvl_gauss_sigma_to_k()</a>. 
</div>
</div><p>
<a class="anchor" name="65696a20455019b05162fa1eff2ac486"></a><!-- doxytag: member="cvl_filter.h::cvl_min" ref="65696a20455019b05162fa1eff2ac486" args="(cvl_frame_t *dst, cvl_frame_t *src, int k_h, int k_v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_min           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction.</td></tr>
  </table>
</dl>
Applies Minimum filtering to a frame. The number of matrix columns will be 2k_h+1, the number of rows will be 2k_v+1. 
</div>
</div><p>
<a class="anchor" name="2ff684e67cfebfc8c9563e6154ad74b9"></a><!-- doxytag: member="cvl_filter.h::cvl_min3d" ref="2ff684e67cfebfc8c9563e6154ad74b9" args="(cvl_frame_t *dst, cvl_frame_t **srcs, int k_h, int k_v, int k_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_min3d           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **&nbsp;</td>
          <td class="paramname"> <em>srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcs</em>&nbsp;</td><td>The source frames. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_t</em>&nbsp;</td><td>Mask size in temporal direction.</td></tr>
  </table>
</dl>
Applies Minimum filtering. See <a class="el" href="cvl__filter_8h.html#9ddf0662c68bfcebbc38543cd8be8fe4">cvl_convolve3d_separable()</a> for a description of <em>frames</em>. The kernel size will be (2k_t+1)x(2k_v+1)x(2k_h+1). 
</div>
</div><p>
<a class="anchor" name="cb49b2e6231b99254c7258575c0cedeb"></a><!-- doxytag: member="cvl_filter.h::cvl_max" ref="cb49b2e6231b99254c7258575c0cedeb" args="(cvl_frame_t *dst, cvl_frame_t *src, int k_h, int k_v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_max           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction.</td></tr>
  </table>
</dl>
Applies Maximum filtering to a frame. The number of matrix columns will be 2k_h+1, the number of rows will be 2k_v+1. 
</div>
</div><p>
<a class="anchor" name="6d4ecd79a80c1c9a4660a0bd54316c29"></a><!-- doxytag: member="cvl_filter.h::cvl_max3d" ref="6d4ecd79a80c1c9a4660a0bd54316c29" args="(cvl_frame_t *dst, cvl_frame_t **srcs, int k_h, int k_v, int k_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_max3d           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **&nbsp;</td>
          <td class="paramname"> <em>srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcs</em>&nbsp;</td><td>The source frames. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_t</em>&nbsp;</td><td>Mask size in temporal direction.</td></tr>
  </table>
</dl>
Applies Maximum filtering. See <a class="el" href="cvl__filter_8h.html#9ddf0662c68bfcebbc38543cd8be8fe4">cvl_convolve3d_separable()</a> for a description of <em>frames</em>. The kernel size will be (2k_t+1)x(2k_v+1)x(2k_h+1). 
</div>
</div><p>
<a class="anchor" name="f3a7af61d9fb85e028f18006879c8951"></a><!-- doxytag: member="cvl_filter.h::cvl_median" ref="f3a7af61d9fb85e028f18006879c8951" args="(cvl_frame_t *dst, cvl_frame_t *src, int k_h, int k_v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_median           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction.</td></tr>
  </table>
</dl>
Applies Median filtering to a frame. The number of matrix columns will be 2k_h+1, the number of rows will be 2k_v+1. 
</div>
</div><p>
<a class="anchor" name="f9f8e377d7f4c2f69cdf6e2e0cf5cec4"></a><!-- doxytag: member="cvl_filter.h::cvl_median3d" ref="f9f8e377d7f4c2f69cdf6e2e0cf5cec4" args="(cvl_frame_t *dst, cvl_frame_t **srcs, int k_h, int k_v, int k_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_median3d           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **&nbsp;</td>
          <td class="paramname"> <em>srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcs</em>&nbsp;</td><td>The source frames. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_t</em>&nbsp;</td><td>Mask size in temporal direction.</td></tr>
  </table>
</dl>
Applies Median filtering. See <a class="el" href="cvl__filter_8h.html#9ddf0662c68bfcebbc38543cd8be8fe4">cvl_convolve3d_separable()</a> for a description of <em>frames</em>. The kernel size will be (2k_t+1)x(2k_v+1)x(2k_h+1). 
</div>
</div><p>
<a class="anchor" name="e91bb38635992a557efabc4923494a98"></a><!-- doxytag: member="cvl_filter.h::cvl_median_separated" ref="e91bb38635992a557efabc4923494a98" args="(cvl_frame_t *dst, cvl_frame_t *src, int k_h, int k_v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_median_separated           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction.</td></tr>
  </table>
</dl>
Applies approximated Median filtering to a frame. The Median filter is separated for this purpose. The results are usually close to the real median filter results. The number of matrix columns will be 2k_h+1, the number of rows will be 2k_v+1. 
</div>
</div><p>
<a class="anchor" name="037430b75e1c4f741411a2aa88d84f48"></a><!-- doxytag: member="cvl_filter.h::cvl_median3d_separated" ref="037430b75e1c4f741411a2aa88d84f48" args="(cvl_frame_t *dst, cvl_frame_t **srcs, int k_h, int k_v, int k_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_median3d_separated           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> **&nbsp;</td>
          <td class="paramname"> <em>srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k_t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcs</em>&nbsp;</td><td>The source frames. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_h</em>&nbsp;</td><td>Mask size in horizontal direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_v</em>&nbsp;</td><td>Mask size in vertical direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k_t</em>&nbsp;</td><td>Mask size in temporal direction.</td></tr>
  </table>
</dl>
Applies approximated Median filtering. The Median filter is separated for this purpose. The results are usually close to the real median filter results. See <a class="el" href="cvl__filter_8h.html#9ddf0662c68bfcebbc38543cd8be8fe4">cvl_convolve3d_separable()</a> for a description of <em>frames</em>. The kernel size will be (2k_t+1)x(2k_v+1)x(2k_h+1). 
</div>
</div><p>
<a class="anchor" name="9937e892e33fe1a6fabc3104e6ce973d"></a><!-- doxytag: member="cvl_filter.h::cvl_laplace" ref="9937e892e33fe1a6fabc3104e6ce973d" args="(cvl_frame_t *dst, cvl_frame_t *src, float c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_laplace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The sharpness parameter, greater than or equal to zero.</td></tr>
  </table>
</dl>
Sharpens a frame with the Laplacian operator. The parameter <em>c</em> determines the strength of the sharpening effect. This function works best on frames in <a class="el" href="cvl__frame_8h.html#c767ff544742f37f673eafcf50080033bf9b49af460bbab8e05674cfc19f5adf">CVL_XYZ</a> format. 
</div>
</div><p>
<a class="anchor" name="dee615707fccb7ec6e79f6dd46fd37af"></a><!-- doxytag: member="cvl_filter.h::cvl_unsharpmask" ref="dee615707fccb7ec6e79f6dd46fd37af" args="(cvl_frame_t *dst, cvl_frame_t *src, cvl_frame_t *smoothed, float c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvl_unsharpmask           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvl__frame__t.html">cvl_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>smoothed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>smoothed</em>&nbsp;</td><td>A smoothed version of the frame. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The sharpness parameter, from (0.5, 1.0).</td></tr>
  </table>
</dl>
Sharpens the a frame using unsharp masking. The frame <em>smoothed</em> must be a smoothed version of <em>src</em>, for example produced by 3x3 Gauss filtering. The parameter <em>c</em> determines the strength of the sharpening effect. This function works best on frames in <a class="el" href="cvl__frame_8h.html#c767ff544742f37f673eafcf50080033bf9b49af460bbab8e05674cfc19f5adf">CVL_XYZ</a> format. 
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jan 16 20:44:06 2008 for CVL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
