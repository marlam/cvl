<html lang="en">
<head>
<title>cvtool 0.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="cvtool 0.0.1">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual was last updated January 18, 2006 for version
0.0.1 of cvtool.

Copyright (C) 2005, 2006 Martin Lambers

     This program, including this manual, is free software; you can
     redistribute it and/or modify it under the terms of the GNU
     General Public License as published by the Free Software
     Foundation; either version 2 of the License, or (at your option)
     any later version.

     This program, including this manual, is distributed in the hope
     that it will be useful, but WITHOUT ANY WARRANTY; without even the
     implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program and manual; if not, write to the Free
     Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
     Boston, MA 02110-1301, USA.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<h1 class="settitle">cvtool 0.0.1</h1>
<div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">cvtool</a>
<li><a name="toc_Introduction" href="#Introduction">1 Introduction</a>
<ul>
<li><a href="#Introduction">1.1 Concept</a>
<li><a href="#Introduction">1.2 Supported file types</a>
<ul>
<li><a href="#Introduction">1.2.1 NetPBM formats: `<samp><span class="samp">pnm</span></samp>'</a>
<li><a href="#Introduction">1.2.2 YUV4MPEG2 format: `<samp><span class="samp">y4m</span></samp>'</a>
</li></ul>
<li><a href="#Introduction">1.3 Output</a>
<li><a href="#Introduction">1.4 Global options</a>
<li><a href="#Introduction">1.5 Common parameters</a>
<ul>
<li><a href="#Introduction">1.5.1 Arrays and Matrices</a>
<li><a href="#Introduction">1.5.2 Colors</a>
</li></ul>
<li><a href="#Introduction">1.6 Environment</a>
<li><a href="#Introduction">1.7 Exit codes</a>
</li></ul>
<li><a name="toc_Commands" href="#Commands">2 Commands</a>
<ul>
<li><a href="#Commands">2.1 Informational commands</a>
<ul>
<li><a href="#Commands">2.1.1 help</a>
<li><a href="#Commands">2.1.2 version</a>
<li><a href="#Commands">2.1.3 info</a>
</li></ul>
<li><a href="#Commands">2.2 Stream manipulation</a>
<ul>
<li><a href="#Commands">2.2.1 combine</a>
<li><a href="#Commands">2.2.2 convert</a>
<li><a href="#Commands">2.2.3 create</a>
<li><a href="#Commands">2.2.4 foreach</a>
<li><a href="#Commands">2.2.5 merge</a>
<li><a href="#Commands">2.2.6 reverse</a>
<li><a href="#Commands">2.2.7 select</a>
<li><a href="#Commands">2.2.8 split</a>
</li></ul>
<li><a href="#Commands">2.3 Resizing frames</a>
<ul>
<li><a href="#Commands">2.3.1 resize</a>
<li><a href="#Commands">2.3.2 cut</a>
</li></ul>
<li><a href="#Commands">2.4 Transforming frames</a>
<ul>
<li><a href="#Commands">2.4.1 affine</a>
<li><a href="#Commands">2.4.2 flip</a>
<li><a href="#Commands">2.4.3 flop</a>
<li><a href="#Commands">2.4.4 rotate</a>
<li><a href="#Commands">2.4.5 scale</a>
<li><a href="#Commands">2.4.6 shear</a>
</li></ul>
<li><a href="#Commands">2.5 Smoothing and Enhancing frames</a>
<ul>
<li><a href="#Commands">2.5.1 smooth</a>
<li><a href="#Commands">2.5.2 convolve</a>
</li></ul>
<li><a href="#Commands">2.6 Color manipulation</a>
<ul>
<li><a href="#Commands">2.6.1 binarize</a>
<li><a href="#Commands">2.6.2 channel</a>
<li><a href="#Commands">2.6.3 color</a>
<li><a href="#Commands">2.6.4 equalize</a>
<li><a href="#Commands">2.6.5 invert</a>
</li></ul>
<li><a href="#Commands">2.7 Detecting image features</a>
<ul>
<li><a href="#Commands">2.7.1 edge</a>
<li><a href="#Commands">2.7.2 opticalflow</a>
</li></ul>
<li><a href="#Commands">2.8 Comparing frames</a>
<ul>
<li><a href="#Commands">2.8.1 diff</a>
</li></ul>
<li><a href="#Commands">2.9 Stereoscopic image pairs</a>
<ul>
<li><a href="#Commands">2.9.1 dibr</a>
<li><a href="#Commands">2.9.2 stereoview</a>
<li><a href="#Commands">2.9.3 trackdepth</a>
</li></ul>
<li><a href="#Commands">2.10 Miscellaneous</a>
<ul>
<li><a href="#Commands">2.10.1 blend</a>
<li><a href="#Commands">2.10.2 grid</a>
<li><a href="#Commands">2.10.3 vectors</a>
</li></ul>
</li></ul>
<li><a name="toc_Examples" href="#Examples">3 Examples</a>
<ul>
<li><a href="#Examples">3.1 Creating a stereoscopic image from a single 2D image</a>
<ul>
<li><a href="#Examples">3.1.1 Introduction</a>
<li><a href="#Examples">3.1.2 Creating a depth map</a>
<li><a href="#Examples">3.1.3 Depth Image Based Rendering</a>
<li><a href="#Examples">3.1.4 Viewing the result</a>
</li></ul>
<li><a href="#Examples">3.2 Creating a stereoscopic video from a 2D video</a>
<ul>
<li><a href="#Examples">3.2.1 Depth Tracking</a>
</li></ul>
</li></ul>
<li><a name="toc_Enhancing-cvtool" href="#Enhancing-cvtool">4 Enhancing cvtool</a>
<li><a name="toc_Command-index" href="#Command-index">Appendix A Command index</a>
</li></ul>
</div>



<div class="node">
<p><hr>
<a name="Top"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">cvtool</h2>

<p>This manual was last updated January 18, 2006 for version
0.0.1 of cvtool.

   <p>Copyright &copy; 2005, 2006 Martin Lambers

   <blockquote>
This program, including this manual, is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public License as published
by the Free Software Foundation; either version 2 of the License, or (at your
option) any later version.

        <p>This program, including this manual, is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
Public License for more details.

        <p>You should have received a copy of the GNU General Public License along with
this program and manual; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA. 
</blockquote>

<ul class="menu">
<li><a accesskey="1" href="#Introduction">Introduction</a>
<li><a accesskey="2" href="#Commands">Commands</a>
<li><a accesskey="3" href="#Examples">Examples</a>
<li><a accesskey="4" href="#Enhancing-cvtool">Enhancing cvtool</a>
<li><a accesskey="5" href="#Command-index">Command index</a>
</ul>

<div class="node">
<p><hr>
<a name="Introduction"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Commands">Commands</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Introduction</h2>

<h3 class="section">1.1 Concept</h3>

<p>Cvtool is a filter that manipulates one or more images: it reads images from
standard input and writes the manipulated images to standard output. It can
read and write streams of NetPBM images (ppm, pgm, pbm) and video streams in
the YUV4MPEG2 format used by the MJPEG Tools.

   <p>Cvtool integrates all its functionality into a single binary, and makes
it available through commands such as <code>rotate</code>, <code>smooth</code>, and
others.

   <p>The following command scales a NetPBM image by a factor of 3:
<pre class="example">     $ cvtool scale --factor 3.0 &lt; input.ppm &gt; output.ppm
</pre>
   <p>This is how one would select a rectangle from a YUV4MPEG2 video stream:
<pre class="example">     $ cvtool cut --left 10 --top 10 --width 100 --height 100 \
       &lt; input.y4m &gt; output.y4m
</pre>
   <p><code>cvtool help</code> prints a list of available commands, and
<code>cvtool help cmd</code> prints help for the command <code>cmd</code>.

<h3 class="section">1.2 Supported file types</h3>

<h4 class="subsection">1.2.1 NetPBM formats: `<samp><span class="samp">pnm</span></samp>'</h4>

<p>All NetPBM image formats (pbm, pgm, ppm, pam) are supported, except for their
old "plain" variants. Multiple images in one file are supported. They may
differ in size and type.

   <p>Cvtool always uses 256 values per color channel. If the input uses a different
number, it will be converted, and a warning will be issued.

<h4 class="subsection">1.2.2 YUV4MPEG2 format: `<samp><span class="samp">y4m</span></samp>'</h4>

<p>Cvtool supports a subset of the YUV4MPEG2 format as used by MJPEG Tools.

   <p>The following features are not yet supported:
     <ul>
<li>Chroma subsampling other than 420jpeg and 444
<li>X-tags for streams
<li>X-tags for frames
<li>Interlacing
</ul>

   <p>Internally, cvtool works with chroma information for each pixel. This
corresponds to the 444 chroma subsampling type of the YUV4MPEG2 format.  The
420jpeg subsampling type stores chroma information only for groups of 4 pixels,
which may mean a loss of information.

   <p>Cvtool will keep the chroma type of the input files, which is 420jpeg in most cases,
and it will use the 420jpeg type by default when creating new `<samp><span class="samp">y4m</span></samp>' streams. 
This is because many tools, including mpeg2enc and MPlayer, only accept 420jpeg subsampling.

   <p>To preserve the full chroma information across several stream manipulation
steps, the 444 subsampling must be requested explicitly, for example with the
convert command:
<pre class="example">     $ cvtool convert --chroma 444 &lt; input.y4m \
       | ... manipulate frames ... \
       | cvtool convert --chroma 420jpeg \
       | mpeg2enc -f4 -o video.mpg
</pre>
   <h3 class="section">1.3 Output</h3>

<p>Cvtool normally prints messages to <code>stderr</code>. It prepends messages with its
name, the level of information, and the name of the command.

   <p>The level of information is <code>DBG</code> for debugging messages, <code>INF</code> for
informational messages, <code>WRN</code> for warnings, <code>ERR</code> for error
messages, and <code>REQ</code> for requested information. Normally, cvtool prints only
messages of level <code>INF</code> or higher, but this can be changed with
<samp><span class="option">--quiet</span></samp> and <samp><span class="option">--verbose</span></samp>; see below.

   <p>Some commands, for example <samp><span class="command">info</span></samp>, print special information messages
that the user explicitly requests. Such special messages have the level
<code>REQ</code>, and can usually be redirected using the <samp><span class="option">--output</span></samp> option. 
In this case, no additional information will be prepended to the messages.

   <p>The special filename <code>-</code> means standard output (<code>stdout</code>). 
Redirecting messages to <code>stdout</code> is only allowed when no images are
written to <code>stdout</code>.

<h3 class="section">1.4 Global options</h3>

     <dl>
<dt><code>-q|--quiet</code><dd>Reduces the amount of output: only messages with level <code>WRN</code>
and higher will be printed.

     <br><dt><code>-v|--verbose</code><dd>Increases the amount of output: all messages will be printed, even those
with level <code>DBG</code>. This will include progress information in many
cases, but much of the output is really only useful for debugging purposes. 
</dl>

<h3 class="section">1.5 Common parameters</h3>

<h4 class="subsection">1.5.1 Arrays and Matrices</h4>

<p>Some commands need arrays of integer or floating point values as parameters. 
Matrices are treated as two-dimensional arrays. Higher dimensions are also
possible.

   <p>All of these array types are treated the same: the first part of the argument
determines the number of dimensions of the array and its size in each
dimension. The second part lists all values, separated by commas.

   <p>If the command requests an array or matrix of fixed dimension and size (or of
dimension 1 and arbitrary size), then the first part can be omitted: only the
value list is necessary in this case.

   <p>Examples:
     <ul>
<li>An array with three integer values
     <pre class="example">          3:1,1,1
     </pre>
     <li>An array with five floating point values
     <pre class="example">          5:1.2,1.3,0.7,0.5,0.0
          1.2,1.3,0.7,0.5,0.0
     </pre>
     <li>A 3x3 matrix array with integer values
     <pre class="example">          3x3:1,2,3,4,5,6,7,8,9
     </pre>
     <li>A three-dimensional array with floating point values
     <pre class="example">          2x2x2:1.11,1.12,1.21,1.22,2.11,2.12,2.21,2.22
     </pre>
     </ul>

<h4 class="subsection">1.5.2 Colors</h4>

<p>Colors can be given in one of three forms:
     <ol type=1 start=1>
<li>X11 color names<br>
X11 comes with a file rgb.txt that defines names for lots of colors. 
Cvtool accepts each of these names, case insensitively. 
The full list can be found here: <a href="http://cvs.freedesktop.org/*checkout*/xorg/xc/programs/rgb/rgb.txt">http://cvs.freedesktop.org/*checkout*/xorg/xc/programs/rgb/rgb.txt</a>. 
<li>Hex triplets<br>
The RGB components of a color can be specified directly as a hex triplet: 0xrrggbb. 
For example, 0xffffff is white and 0x000000 is black. 
<li>Triplet of decimal values<br>
The RGB components of a color can be specified directly as a triplet of decimal values: rrr,ggg,bbb. 
For example, 255,255,255 is white and 0,0,0 is black.
        </ol>

<h3 class="section">1.6 Environment</h3>

     <dl>
<dt><samp><span class="env">TMPDIR</span></samp><dd>Directory to create temporary files in. 
<br><dt><samp><span class="env">COLUMNS</span></samp><dd>Cvtool tries to format its messages so that they do not use more than the given number of columns. 
If this variable is unset, a default of 80 will be used. 
</dl>

<h3 class="section">1.7 Exit codes</h3>

<p>Cvtool returns <code>0</code> on success and <code>1</code> on error.

<div class="node">
<p><hr>
<a name="Commands"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Examples">Examples</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Commands</h2>

<h3 class="section">2.1 Informational commands</h3>

<p><a name="index-help-1"></a>

<h4 class="subsection">2.1.1 help</h4>

<p><code>help [</code><var>command</var><code>]</code>

<p class="noindent">Print general or command specific help.

   <p><a name="index-version-2"></a>

<h4 class="subsection">2.1.2 version</h4>

<p><code>version</code>

<p class="noindent">Print version information.

   <p><a name="index-info-3"></a>

<h4 class="subsection">2.1.3 info</h4>

<p><code>info [-o|--output=</code><var>file</var><code>]</code>

<p class="noindent">Print information about the first frame in a stream to stderr or to the given
file ('-' means stdout).<br>
The following information will be printed: <code>STREAMTYPE</code> (`<samp><span class="samp">y4m</span></samp>' or `<samp><span class="samp">pnm</span></samp>'),
<code>PIXELTYPE</code> (`<samp><span class="samp">yuv</span></samp>' for `<samp><span class="samp">y4m</span></samp>' streams, `<samp><span class="samp">rgb</span></samp>' or `<samp><span class="samp">gray</span></samp>' for `<samp><span class="samp">pnm</span></samp>' streams),
<code>WIDTH</code>, <code>HEIGHT</code>, and, if <code>STREAMTYPE</code> is `<samp><span class="samp">y4m</span></samp>', <code>CHROMA</code>,
<code>INTERLACING</code>, <code>FRAMERATE</code>, <code>ASPECTRATIO</code>.<br>
In a `<samp><span class="samp">y4m</span></samp>' stream, all frames are of the same type, and the information thus applies to
the whole stream. This is not true for `<samp><span class="samp">pnm</span></samp>' streams!
<pre class="example">     $ cvtool info &lt; file.pnm
     cvtool: [INF] info: STREAMTYPE=pnm PIXELTYPE=rgb WIDTH=352 HEIGHT=240
     $ eval `cvtool info -o - &lt; file.pnm`
     $ echo $WIDTH
     352
</pre>
   <h3 class="section">2.2 Stream manipulation</h3>

<p><a name="index-combine-4"></a>

<h4 class="subsection">2.2.1 combine</h4>

<p><code>combine [-m|--method=(lr|leftright)|(tb|topbottom)]
[-j|--justify=(left|top)|center|(right|bottom)] [-c|--color=</code><var>color</var><code>]
</code><var>file<small class="dots">...</small></var>

<p class="noindent">Combine the given files by placing the frames side by side
(`<samp><span class="samp">leftright</span></samp>') or one below the other (`<samp><span class="samp">topbottom</span></samp>'). The default
is `<samp><span class="samp">leftright</span></samp>'. If the frames have different sizes, then the
smaller ones have to be aligned with the biggest one. The
default is to center them. The remaining space will be
filled with the given color; the default is black.
<pre class="example">     $ cvtool combine left.pnm right.pnm &gt; lr.pnm
     $ cvtool combine -m tb \
       &lt;(cvtool combine a.pnm b.pnm) \
       &lt;(cvtool combine c.pnm d.pnm) \
       &gt; 2x2.pnm
</pre>
   <p><a name="index-convert-5"></a>

<h4 class="subsection">2.2.2 convert</h4>

<p><code>convert [-o|--output-type=pnm|y4m] [-g|--gray] [-C|--chroma=420jpeg|444]
[-F|--framerate=</code><var>f1:f2</var><code>] [-A|--aspect-ratio=</code><var>a1:a2</var><code>]</code>

<p class="noindent">Convert input to `<samp><span class="samp">pnm</span></samp>' or `<samp><span class="samp">y4m</span></samp>' format. The default is to keep the input
format.<br>
The <samp><span class="option">--gray</span></samp> option converts each frame to graylevels. For the `<samp><span class="samp">pnm</span></samp>'
output type, this is the only option that has any effect; the others are
silently ignored.<br>
For `<samp><span class="samp">y4m</span></samp>', the chroma subsampling, frame rate, and aspect ratio can be
given. The default is to incur them from the input stream. If the input
stream is not a `<samp><span class="samp">y4m</span></samp>' stream, the defaults are `<samp><span class="samp">0:0</span></samp>' ("unknown")
for frame rate and aspect ratio, and `<samp><span class="samp">420jpeg</span></samp>' for chroma subsampling.
<pre class="example">     $ cvtool convert -C 444 &lt; in.y4m &gt; out.y4m
     $ cvtool convert -o pnm &lt; video.y4m &gt; video.pnm
</pre>
   <p><a name="index-create-6"></a>

<h4 class="subsection">2.2.3 create</h4>

<p><code>create [-t|--type=gray|rgb|yuv] [-n|--n=</code><var>n</var><code>] -w|--width=</code><var>w</var><code>
-h|--height=</code><var>h</var><code> [-c|--color=</code><var>color</var><code>] [-C|--chroma=420jpeg|444]
[-F|--framerate=</code><var>f1:f2</var><code>] [-A|--aspect-ratio=</code><var>a1:a2</var><code>]</code>

<p class="noindent">Create <var>n</var> (default 1) frames of pixel type `<samp><span class="samp">gray</span></samp>',
`<samp><span class="samp">rgb</span></samp>' or `<samp><span class="samp">yuv</span></samp>' (default `<samp><span class="samp">rgb</span></samp>'), with the given width and height, filled
with the given color (default black). The resulting stream
type will be `<samp><span class="samp">pnm</span></samp>' for `<samp><span class="samp">gray</span></samp>' and `<samp><span class="samp">rgb</span></samp>' frames, and `<samp><span class="samp">y4m</span></samp>'
for `<samp><span class="samp">yuv</span></samp>' frames. The chroma subsampling, frame rate, and
aspect ratio information is only relevant for the `<samp><span class="samp">yuv</span></samp>' type;
it will be silently ignored for the other types.
<pre class="example">     $ cvtool create -t yuv -F 25:1 -w 720 -h 576 -n 250 &gt; 10-seconds-PAL.y4m
     $ cvtool create -t rgb -w 720 -h 576 -c green &gt; green.pgm
</pre>
   <p><a name="index-foreach-7"></a>

<h4 class="subsection">2.2.4 foreach</h4>

<p><code>foreach [-s|--shell=</code><var>shell</var><code>] [-n|--n=</code><var>n</var><code>] </code><var>cmd</var>

<p class="noindent">Execute the given command for every frame. The command is
expected to read <var>n</var> frames from standard input (default is <var>n</var>=1),
and write an arbitrary number (including zero) of
frames to standard output. The original frame(s) that were
given to the command are replaced by the output of the
command. The frames that the command produces are converted
to the format of the original frames. The foreach command
replaces the following special strings in the command <var>cmd</var>
before executing the command: <code>%N</code> (replaced with frame
number), <code>%W</code> (replaced with frame width), and <code>%H</code> (replaced
with frame height). If <var>n</var> is greater than 1, these values
refer to the first frame that is piped to the command. 
The command <var>cmd</var> is executed by passing it to the system shell. 
The default is `<samp><span class="samp">/bin/sh -c</span></samp>' on most systems. This can be
overridden with the <samp><span class="option">--shell</span></samp> option. It
expects a string with zero or one spaces: The first part of
the string is the shell, the second part (if any) is the
first option to the shell. The next option will then be the
command to execute.
<pre class="example">     $ cvtool foreach 'cvtool info' &lt; many-images.pnm
     
     # Rotate a video. Use chroma 444 to allow odd width/height. Resize after
     # rotation to keep the original dimensions.
     $ cvtool convert -C 444 &lt; video.y4m \
       | cvtool foreach 'cvtool rotate -a %N | cvtool resize -w 352 -h 240' \
       | cvtool convert -C 420jpeg \
       &gt; rotating-video.y4m
</pre>
   <p><a name="index-merge-8"></a>

<h4 class="subsection">2.2.5 merge</h4>

<p><code>merge [-s|--shuffle] [-o|--output=</code><var>file</var><code>] </code><var>file<small class="dots">...</small></var>

<p class="noindent">Merges files into one stream, in the given order. If
<code>--shuffle</code> is used, the order will be randomized. The file
names will be printed to stderr in the order they are
merged. If <code>--output</code> is used, the file names will be written
to the given file instead.
<pre class="example">     $ ls
     frame000.pnm frame001.pnm frame002.pnm
     $ cvtool merge * | cvtool convert -o y4m &gt; video.y4m
</pre>
   <p><a name="index-reverse-9"></a>

<h4 class="subsection">2.2.6 reverse</h4>

<p><code>reverse</code>

<p class="noindent">Reverses the order of the frames in the stream. 
This requires a temporary file that is big enough to hold the complete input stream.
<pre class="example">     $ cvtool reverse &lt; video.y4m &gt; oediv.y4m
</pre>
   <p><a name="index-select-10"></a>

<h4 class="subsection">2.2.7 select</h4>

<p><code>select [-d|--drop] </code><var>range<small class="dots">...</small></var>

<p class="noindent">Selects frames from a stream. By default, frames in the given ranges are kept and all others
dropped. With <code>--drop</code>, frames in the given ranges are dropped and all others kept.<br>
A range must be of the following form: <var>l</var>-<var>h</var> (from <var>l</var> to
<var>h</var>), -<var>h</var> (from beginning to <var>h</var>), <var>l</var>- (from <var>l</var> to end),
<var>l</var> (only <var>l</var>), or - (everything).  Each start and end point can be a
frame number (counting from 0) or a time in the format
[hours:]minutes:seconds[.fraction]. In short: if it contains a colon, it's a
time. Time ranges can only be used for YUV4MPEG2 streams with known frame rate. 
IMPORTANT: If you use frame number ranges, the high frame number is inclusive:
the frame with this number will be dropped/kept. If you use time ranges, the
high time is exclusive and marks the first frame that will not be dropped/kept.
<pre class="example">     # Drop the frames 0 to 124 from the stream (with a framerate of 25 fps,
     # these are the first five seconds).
     $ cvtool select --drop 0-124 &lt; in.y4m &gt; out.y4m
     
     # Drop the first 5 seconds of the stream (with a framerate of 25 fps,
     # these are the frames 0 to 124. The frame at 0:05, with the frame
     # number 125, will be the first that is kept!)
     $ cvtool select --drop 0:00-0:05 &lt; in.y4m &gt; out.y4m
     
     # Keep the second 5-minutes-block and drop all the rest. Both
     # commands are equivalent.
     $ cvtool select 5:00-10:00 &lt; in.y4m &gt; out.y4m
     $ cvtool select --drop -5:00 10:00- &lt; in.y4m &gt; out.y4m
</pre>
   <p><a name="index-split-11"></a>

<h4 class="subsection">2.2.8 split</h4>

<p><code>split [-n|--n=</code><var>n</var><code>] [-t|--template=</code><var>template</var><code>] [-b|--backwards]
[-s|--start=</code><var>i</var><code>]</code>

<p class="noindent">Split the input stream into multiple files, each containing
<var>n</var> frames (default is <var>n</var>=1). The filename will be generated
from the template: the template must contain exactly one
appearance of the character <code>%</code>. This character must be
followed by one of the digits <code>1</code> through <code>9</code>. The digit must be
followed by the uppercase character <code>N</code>. This special string
<code>%xN</code> will be replaced by the number of the first frame of the
stream contained in this file. The number will be
left-padded with zeros until its width is at least <code>x</code>
characters. The default template is `<samp><span class="samp">frame-%6N</span></samp>'. 
A start number i for the first frame can be given, and the
frames can be counted backwards. If the frames are counted
backwards, a start number is required, because negative
frame numbers are not accepted.
<pre class="example">     $ cvtool split -t frame%3N.pnm &lt; ../video.y4m
     $ ls
     frame000.pnm frame001.pnm frame002.pnm
     $ cvtool split -s 99 -b -t img%2N.pnm &lt; ../video.y4m
     $ ls
     img99.pnm img98.pnm img97.pnm
</pre>
   <h3 class="section">2.3 Resizing frames</h3>

<p><a name="index-resize-12"></a>

<h4 class="subsection">2.3.1 resize</h4>

<p><code>resize -w|--width=</code><var>w</var><code> -h|--height=</code><var>h</var><code> [-x|--x-offset=</code><var>x</var><code>]
[-y|--y-offset=</code><var>y</var><code>] [-c|--color=</code><var>color</var><code>]</code>

<p class="noindent">Resize the frames to the given new width and height. Place
the original frame contents at the position (<var>x</var>,<var>y</var>) relative
to the new frame (these offsets may be negative). If no or
an incomplete position is given, compute the missing part(s)
so that the old contents are centered on the new frame. Fill
holes that might result with the given color (default is
black).
<pre class="example">     $ cvtool info &lt; img.pnm
     cvtool: [INF] info: STREAMTYPE=pnm PIXELTYPE=rgb WIDTH=352 HEIGHT=240
     # Add a green border of 10 pixels
     $ cvtool resize -w 372 -h 260 -c green &lt; img.pnm &gt; img2.pnm
</pre>
   <p><a name="index-cut-13"></a>

<h4 class="subsection">2.3.2 cut</h4>

<p><code>cut -l|--left=</code><var>l</var><code> -t|--top=</code><var>t</var><code> -w|--width=</code><var>w</var><code>
-h|--height=</code><var>h</var>

<p class="noindent">Only let the given rectangle through; cut the rest of each frame.
<pre class="example">     $ cvtool cut -l 0 -t 0 -w 10 -h 10 &lt; in.pnm &gt; out.pnm
</pre>
   <h3 class="section">2.4 Transforming frames</h3>

<p><a name="index-affine-14"></a>

<h4 class="subsection">2.4.1 affine</h4>

<p><code>affine -m|--matrix=</code><var>2x2-matrix</var><code> [-c|--color=</code><var>color</var><code>]
[-i|--interpolation=none|bilinear]</code>

<p class="noindent">Apply the affine tranformation defined by the given matrix
(4 floating point values separated by commas) to the frames. 
The frame dimensions will be adapted so that the resulting
image will fit. Possible holes will be filled with the given
color; the default is black. The default interpolation type
is bilinear.
<pre class="example">     $ cvtool affine -m 2.0,0.1,0.75,1.0 &lt; in.pnm &gt; out.pnm
</pre>
   <p><a name="index-flip-15"></a>

<h4 class="subsection">2.4.2 flip</h4>

<p><code>flip</code>

<p class="noindent">Flip frames (left/right).
<pre class="example">     $ cvtool flip &lt; in.pnm &gt; out.pnm
</pre>
   <p><a name="index-flop-16"></a>

<h4 class="subsection">2.4.3 flop</h4>

<p><code>flop</code>

<p class="noindent">Flop frames (top/bottom).
<pre class="example">     $ cvtool flop &lt; in.pnm &gt; out.pnm
</pre>
   <p><a name="index-rotate-17"></a>

<h4 class="subsection">2.4.4 rotate</h4>

<p><code>rotate -a|--angle=</code><var>angle</var><code> [-c|--color=</code><var>color</var><code>]
[-i|--interpolation=none|bilinear]</code>

<p class="noindent">Rotate frames with the given angle (in degrees),
counterclockwise. The dimensions of the rotated frame will
be big enough to hold all informations from the source. 
"Holes" will be filled with the given color; the default is
black. The default interpolation type is bilinear (simple
rotations (90, 180, or 270) do not need interpolation).
<pre class="example">     $ cvtool rotate -a -45 &lt; in.pnm &gt; out.pnm
</pre>
   <p><a name="index-scale-18"></a>

<h4 class="subsection">2.4.5 scale</h4>

<p><code>scale [-w|--width=</code><var>w</var><code>] [-h|--height=</code><var>h</var><code>]
[-i|--interpolation=none|bilinear]</code><br>
<code>scale -x|--factor-x=</code><var>factor-x</var><code> -y|--factor-y=</code><var>factor-y</var><code>
[-i|--interpolation=none|bilinear]</code><br>
<code>scale -f|--factor=</code><var>factor</var><code> [-i|--interpolation=none|bilinear]</code>

<p class="noindent">Scale frames to new size. The default interpolation type is bilinear.<br>
First form: Give new width and/or height. If one value is missing, it is
computed from the other so that the aspect ratio remains the same.<br>
Second form: Give scale factors for width and height.<br>
Third form: Give one scale factor for both width and height.
<pre class="example">     $ cvtool info &lt; in.pnm
     cvtool: [INF] info: STREAMTYPE=pnm PIXELTYPE=rgb WIDTH=400 HEIGHT=200
     # The following three commands do the same:
     $ cvtool scale -w 100 -h 50    &lt; in.pnm &gt; out.pnm
     $ cvtool scale -x 0.25 -y 0.25 &lt; in.pnm &gt; out.pnm
     $ cvtool scale -f 0.25         &lt; in.pnm &gt; out.pnm
</pre>
   <p><a name="index-shear-19"></a>

<h4 class="subsection">2.4.6 shear</h4>

<p><code>shear [-x|--shear-x=</code><var>angle-x</var><code>] [-y|--shear-y=</code><var>angle-y</var><code>] [-c|--color=</code><var>color</var><code>]
[-i|--interpolation=none|bilinear]</code>

<p class="noindent">Shear frames in horizontal and/or vertical direction, with the given angle(s)
from (-90,90). Negative angles shear clockwise. "Holes" will be filled with the
given color; the default is black. The default interpolation type is bilinear.
<pre class="example">     $ cvtool shear -x 20 -y 10 &lt; in.pnm &gt; out.pnm
</pre>
   <h3 class="section">2.5 Smoothing and Enhancing frames</h3>

<p><a name="index-smooth-20"></a>

<h4 class="subsection">2.5.1 smooth</h4>

<p><code>smooth average [-3|--3d] -k|--k=</code><var>k</var><br>
<code>smooth average [-3|--3d] -x|--k-x=</code><var>kx</var><code> -y|--k-y=</code><var>ky</var><code> [-t|--k-t=</code><var>kt</var><code>]</code><br>
<code>smooth median [-3|--3d] -k|--k=</code><var>k</var><br>
<code>smooth median [-3|--3d] -x|--k-x=</code><var>kx</var><code> -y|--k-y=</code><var>ky</var><code> [-t|--k-t=</code><var>kt</var><code>]</code><br>
<code>smooth gauss [-3|--3d] -k|--k=</code><var>k</var><br>
<code>smooth gauss [-3|--3d] -x|--k-x=</code><var>kx</var><code> -y|--k-y=</code><var>ky</var><code> [-t|--k-t=</code><var>kt</var><code>]</code><br>
<code>smooth gauss [-3|--3d] [-k|--k=</code><var>k</var><code>] [-x|--k-x=</code><var>kx</var><code>]
[-y|--k-y=</code><var>ky</var><code>] [-t|--k-t=</code><var>kt</var><code>] [-s|--sigma=</code><var>s</var><code>]
[--sigma-x=</code><var>sx</var><code>] [--sigma-y=</code><var>sy</var><code>] [--sigma-t=</code><var>st</var><code>]</code>

<p class="noindent">Smooth frames, in 2D or 3D (with the third dimension being the
time). The kernel size can be given for each dimension, or
once for all. It will be (2<var>kx</var>+1)x(2<var>ky</var>+1)[x(2<var>kt</var>+1)]. Different
values for each direction lead to asymmetric smoothing. The
gauss filter can be specified by the sigma value(s): the
mask size will be computed so that roughly 95% of the mass
lies within the resulting mask. It is also possible to
specify both <var>sigma</var> and <var>k</var>.
<pre class="example">     $ cvtool smooth gauss --3d -k 3 &lt; video.y4m &gt; smoothed-video.y4m
</pre>
   <p><a name="index-convolve-21"></a>

<h4 class="subsection">2.5.2 convolve</h4>

<p><code>convolve -K|--kernel=</code><var>K</var><br>
<code>convolve -X|--vector-x=</code><var>X</var><code> -Y|--vector-y=</code><var>Y</var><code> [-T|--vector-t=</code><var>T</var><code>]</code>

<p class="noindent">Convolve frames with the given convolution kernel. Both 2D
and 3D kernels are accepted (the third dimension is the
time). If the kernel is separable, the vectors that generate
it can be given instead, to reduce computation costs. All
kernel elements must be integers. The size of the kernel
must be an odd number in each dimension.
<pre class="example">     # Both commands are equivalent to 2D smoothing with the
     # average filter with k=1:
     $ cvtool convolve -K 3x3:1,1,1,1,1,1,1,1,1 &lt; in.pnm &gt; out.pnm
     $ cvtool convolve -X 3:1,1,1 -Y 3:1,1,1    &lt; in.pnm &gt; out.pnm
</pre>
   <h3 class="section">2.6 Color manipulation</h3>

<p><a name="index-binarize-22"></a>

<h4 class="subsection">2.6.1 binarize</h4>

<p><code>binarize global -t|--threshold=</code><var>t</var><br>
<code>binarize iterative</code><br>
<code>binarize otsu</code><br>
<code>binarize hysterese -l|--low=</code><var>l</var><code> -h|--high=</code><var>h</var><br>
<code>binarize local -T|--type=mean|median|minmax -k|--k=</code><var>k</var><code> -C|--constant=</code><var>C</var>

<p class="noindent">Convert input to grayscale (if necessary), then binarize it
using the given method.<br>
The global method turns every pixel to black whose value is
lower than the given threshold; all over pixels are turned
to white. The threshold must be from [0,256].<br>
The iterative and otsu methods are global methods, too, but
they compute the threshold automatically.<br>
The hysterese method is not adequate for general images; it
is mainly used by the Canny edge detector. It uses a low and
a high threshold; both must be in [0,255], and should be
chosen so that 2<var>l</var> &lt;= <var>h</var> &lt;= 4<var>l</var>.<br>
The local method uses a local threshold (<var>T</var>-<var>C</var>) for a
neighborhood of size (2<var>k</var>+1)x(2<var>k</var>+1), where <var>T</var> is the mean of all
pixel values in the neighborhood, the median of the pixel
values, or the mean of the minimum and maximum of the pixel
values. <var>C</var> can be negative. The mean type is much faster than
median and minmax.
<pre class="example">     $ cvtool binarize local -T median -k 5 -C 20 &lt; gray.pgm &gt; bw.pgm
</pre>
   <p><a name="index-channel-23"></a>

<h4 class="subsection">2.6.2 channel</h4>

<p><code>channel -c|--channel=r|g|b</code>

<p class="noindent">Pick the given channel from the input.
<pre class="example">     $ cvtool channel -c r &lt; colored.pnm &gt; red.pnm
</pre>
   <p><a name="index-color-24"></a>

<h4 class="subsection">2.6.3 color</h4>

<p><code>color [-h|--hue=</code><var>h</var><code>] [-s|--saturation=</code><var>s</var><code>]
[-l|--lightness=</code><var>l</var><code>] [-c|--contrast=</code><var>c</var><code>]
[-g|--gamma=(</code><var>g</var><code>|</code><var>gr</var><code>,</code><var>gg</var><code>,</code><var>gb</var><code>)]</code>

<p class="noindent">Color adjustment.<br>
Hue, saturation, lightness, and constrast are manipulated in
the HSL (Hue, Saturation, Lightness) color space. <var>h</var> is an
additive constant to the hue angle, in degrees. <var>s</var>, <var>l</var>, <var>c</var>
measure the relative change in saturation, lightness,
contrast: -1 means the result will be zero, 0 means the
result will be the same as the original, and +1 means that
the result will be two times as high as the original. Values
greater than +1 are possible. For example, s = -1 will
convert the input images to graylevels. See
<a href="http://en.wikipedia.org/wiki/HLS_color_space">http://en.wikipedia.org/wiki/HLS_color_space</a> for more information on
the HSL color space.<br>
Gamma correction (option <samp><span class="option">--gamma</span></samp> is applied to the gray channel for
`<samp><span class="samp">gray</span></samp>' frames, to the Y channel for `<samp><span class="samp">yuv</span></samp>' frames, and to the R,G,B
channels for `<samp><span class="samp">rgb</span></samp>' frames.  If three gamma values are given, the frames
are always converted to `<samp><span class="samp">rgb</span></samp>', then gamma corrected for each channel
separately, and then converted back to their original type. All gamma values
must be greater than zero. Values greater than 1.0 lighten the image, values
smaller than 1.0 darken them.
<pre class="example">     $ cvtool color -h 120 &lt; red.pnm &gt; green.pnm
     $ cvtool color -h 120 &lt; green.pnm &gt; blue.pnm
     $ cvtool color -h 120 &lt; blue.pnm &gt; red.pnm
     $ cvtool color -s -1 &lt; colored.pnm &gt; gray.pnm
     $ cvtool color -l +1 &lt; dark.pnm &gt; light.pnm
     $ cvtool color --gamma 1.4 &lt; dark.pnm &gt; light.pnm
</pre>
   <p><a name="index-equalize-25"></a>

<h4 class="subsection">2.6.4 equalize</h4>

<p><code>equalize</code>

<p class="noindent">Equalize Histogram. Color images are equalized in the Y part
of the YUV color space.
<pre class="example">     $ cvtool equalize &lt; in.pnm &gt; out.pnm
</pre>
   <p><a name="index-invert-26"></a>

<h4 class="subsection">2.6.5 invert</h4>

<p><code>invert</code>

<p class="noindent">Invert input frames.
<pre class="example">     $ cvtool invert &lt; in.pnm &gt; out.pnm
</pre>
   <h3 class="section">2.7 Detecting image features</h3>

<p><a name="index-edge-27"></a>

<h4 class="subsection">2.7.1 edge</h4>

<p><code>edge sobel</code><br>
<code>edge canny -s|--sigma=</code><var>sigma</var><code> -l|--low=</code><var>l</var><code> -h|--high=</code><var>h</var>

<p class="noindent">Detect edges.<br>
Sobel will generate graylevel images: the brighter a point, the stronger the edge.<br>
Canny will generate binary images. The <var>sigma</var> parameter is for Gauss smoothing. 
<var>l</var> and <var>h</var> are used for Hysterese thresholding; both must be from [0,255].
<pre class="example">     $ cvtool edge sobel &lt; in.pgm &gt; gray-edges.pgm
     $ cvtool edge canny -s 1.2 -l 4 -h 8 &lt; in.pgm &gt; bw-edges.pgm
</pre>
   <p><a name="index-opticalflow-28"></a>

<h4 class="subsection">2.7.2 opticalflow</h4>

<p><code>opticalflow hs [-b|--backwards] -l|--lambda=</code><var>l</var><code>
-n|--iterations=</code><var>n</var><br>
<code>opticalflow lk [-b|--backwards] -k|--k=</code><var>k</var><br>
<code>opticalflow clg [-b|--backwards] -l|--lambda=</code><var>l</var><code> -O|--omega=</code><var>O</var><code>
-n|--iterations=</code><var>n</var><br>
<code>opticalflow bm-sad [-b|--backwards] -k|--k=</code><var>k</var><code>
-M|--max-distance=</code><var>m</var><code> -D|--distance-weight=</code><var>dw</var><code>
-L|--luminance-weight=</code><var>lw</var><br>
<code>opticalflow bm-asw [-b|--backwards] -k|--k=</code><var>k</var><code>
-M|--max-distance=</code><var>m</var><code> -c|--gamma-c=</code><var>gc</var><code> -p|--gamma-p=</code><var>gp</var><br>
<code>opticalflow cc -t|--tolerance=</code><var>t</var><code> [-w|--warning-level=</code><var>w</var><code>]
[-o|--output=</code><var>file</var><code>] -f|--verification-flow=</code><var>file</var>

<p class="noindent">Compute the optical flow between frames. For <var>n</var> input frames, this command will
produce <var>n</var>-1 fields of optical flow vectors, in plain text format: the first will contain
the optical flow between the input frames 0 and 1, the second that between 1 and 2, and so forth<br>
If the <code>--backwards</code> option is used, then the optical flow is computed in the opposite direction:
the first flow field will contain the optical flow between frames 1 and 0, the second that between 2 and 1,
and so forth.<br>
The <em>hs</em> (Horn/Schunck) method needs a regularisation parameter lambda (try
10.0), and the number of iterations (try 50).<br>
The <em>lk</em> (Lukas/Kanade) method needs the neighborhood size (2<var>k</var>+1)x(2<var>k</var>+1) as a
parameter.<br>
The <em>clg</em> (Combined Local/Global) method needs a regularization parameter lambda
(try 10.0), a relaxation parameter omega for the iterative SOR method (try
1.95; the value must be between 0 and 2), and the number of iterations (try
50).<br>
The <em>bm-sad</em> (block matching with sum of absoulte differences) method needs the
block size (2<var>k</var>+1)x(2<var>k</var>+1) as a parameter, and the maximum distance that matching
blocks will be searched in. The cost of a block are (dw \cdot distance + (1 - dw) \cdot
average_pixel_difference). The maximum norm distance is used here. Each pixel
difference is calculated with (lw * difference_in_luminance + (1 - lw) *
difference_in_chrominance. The block with the lowest cost is the match; it
determines the optical flow in a given point.  Warning: This method is VERY
SLOW!<br>
The <em>bm-asw</em> (block matching using adaptive support weights) method is a block
matching variant that uses special support weights for cost computation. Try 12
for <var>k</var>, 7 for <var>gc</var> and 36 for <var>gp</var>. This implementation uses a resolution
pyramid to speed the process up and reduce uncertainty in correspondence search. 
Warning: This method is SLOW!<br>
The <em>cc</em> (consistency check) method does not compute optical flow from images. 
Instead, it offers the verification step that improves existing optical flow fields:
the flow fields from <code>stdin</code> are compared against those from the given file. 
Each flow vector in the first set of fields must match its corresponding flow vector in the
second set of fields with the given tolerance. Vector pairs that differ by more than the
given tolerance are marked as unreliable, and are replaced by interpolations of neighboring
reliable vectors. If a warning level between 0 and 1 is given and the fraction of unreliable
vectors is greater than or equal to this level, then a warning is issued for the current flow field pair. 
These warnings can be redirected to a separate file with the <code>--output</code> option.
<pre class="example">     $ cvtool opticalflow bm-sad    -k 8 -M 5 -D 0.01 -L 0.5 \
       &lt; video.y4m &gt; flow-fw.txt
     $ cvtool opticalflow bm-sad -b -k 8 -M 5 -D 0.01 -L 0.5 \
       &lt; video.y4m &gt; flow-bw.txt
     $ cvtool opticalflow cc -t 2 -f flow-bw.txt \
       &lt; flow-fw.txt &gt; flow-fw-improved.txt
     $ cvtool opticalflow cc -t 2 -f flow-fw.txt \
       &lt; flow-bw.txt &gt; flow-bw-improved.txt
</pre>
   <p class="noindent">See also:
     <ul>
<li>For the <code>hs</code> method:<br>
B. Horn and B. Schunck. Determining Optical Flow. <cite>Artificial Intelligence,</cite>
17:185-203, 1981. 
<li>For the <code>lk</code> method:<br>
B. D. Lucas T. and Kanade. An Iterative Image Registration Technique with
an Application to Stereo Vision. In <cite>Proceedings of the Seventh International
Joint Conference on Artificial Intelligence,</cite> pages 674-679, Vancouver, BC,
Canada, April 1981. 
<li>For the <code>clg</code> method:<br>
A. Bruhn, J. Weickert, and C. Schn&ouml;rr. Lucas/Kanade Meets Horn/Schunck:
Combining Local and Global Optic Flow Methods. <cite>International Journal of
Computer Vision,</cite> 61(3):211-231, 2005. 
<li>For the <code>bm-sad</code> method:<br>
TODO
<li>For the <code>bm-asw</code> method:<br>
K.-J. Yoon and I.-S. Kweon. Locally Adaptive Support-Weight Approach
for Visual Correspondence Search. In <cite>Proceedings of the IEEE Conference
on Computer Vision and Pattern Recognition (CVPR),</cite> volume 2, pages 924-931,
San Diego, CA, USA, June 2005. 
</ul>

<h3 class="section">2.8 Comparing frames</h3>

<p><a name="index-diff-29"></a>

<h4 class="subsection">2.8.1 diff</h4>

<p><code>diff [-o|--output=</code><var>file</var><code>] </code><var>file-1</var> <var>file-2</var>

<p class="noindent">Shows the differences between the two sources. The sources must have the same
pixel type, width, and height. This command produces frames of the same
dimensions and of the same pixel type. Each pixel will be the absolute value of
the difference of the corresponding pixels in the two sources. The difference
is computed separated by color channels. Example: p1 = (r11, g12, b13),
p2 = (r3, g11, b13) =&gt; (r8, g1, b0).<br>
In addition to the difference frames, the command will compute the sum of the
absolute differences of all pixel values, divided by the number of pixels. The
value will be printed to stderr, unless the output is redirected with the <samp><span class="option">--output</span></samp>
option. If the output is redirected to <code>stdout</code> (-), then only the difference values
and no frames will be written to <code>stdout</code>. 
`<samp><span class="samp">rgb</span></samp>' and `<samp><span class="samp">yuv</span></samp>' frames produce three error values (one per channel),
printed on a single line.
<pre class="example">     $ cvtool create -w 10 -h 10 -c 255,0,0 &gt; red.pnm
     $ cvtool create -w 10 -h 10 -c 0,255,0 &gt; green.pnm
     $ cvtool diff red.pnm green.pnm &gt; diff.pnm
     cvtool: [REQ] diff: 255 255 0
</pre>
   <h3 class="section">2.9 Stereoscopic image pairs</h3>

<p><a name="index-dibr-30"></a>

<h4 class="subsection">2.9.1 dibr</h4>

<p><code>dibr -d|--depth=</code><var>depthsource</var><code> -b|--b=</code><var>b</var><code> [-p|--position=</code><var>p</var><code>]
[-z|--zps=</code><var>z</var><code>] [-h|--hole-filling=none|average|near|far|linear]</code>

<p class="noindent">Builds stereo images from a source view and corresponding
depth maps. <var>b</var> is the "eye" distance in pixels. The position
of the source view must be in [-1,+1], where -1 means left
view, +1 means right view, and 0 means intermediate view
(this is the default). <var>zps</var> is the zero parallax setting. It
must be in [0,1]; the default is 0. The hole filling method
can be none, average color (default), color of
nearer/farther neighbor pixel, or linear color gradient.
<pre class="example">     $ cvtool dibr -d depth.pgm -b 20 &lt; mono.pnm &gt; stereo.pnm
</pre>
   <p class="noindent">See also:
     <ul>
<li>C. Fehn, K. Hopf, and B. Quante. Key Technologies for an Advanced 3D-TV
System. In <cite>Proceedings of SPIE Three-Dimensional TV, Video and Display
III,</cite> pages 66-80, Philadelphia, PA, USA, October 2004. 
<li>L. Zhang and W. J. Tam. Stereoscopic Image Generation Based on Depth
Images for 3D TV. <cite>IEEE Transactions on Broadcasting,</cite> 51(2):191-199, June 2005. 
<li>TODO
</ul>

   <p><a name="index-stereoview-31"></a>

<h4 class="subsection">2.9.2 stereoview</h4>

<p><code>stereoview anaglyph [-c|--color[=on|off]] [-g|--glasses=red-cyan|red-green|red-blue]</code><br>
<code>stereoview 3d-display -f|--format=lr|tb|ci|ri [-w|--width=</code><var>w</var><code>] [-h|--height=</code><var>h</var><code>]</code>

<p class="noindent">Prepares stereoscopic image pairs for a display device.<br>
<code>anaglyph</code>: converts stereo frames (left and right view side by side) into
anaglyph images, viewable with appropriate color 3D glasses. The default is to
create graylevel anaglyphs for `<samp><span class="samp">red-blue</span></samp>' glasses. It is advisable to lighten the images with
gamma correction before creating anaglyph images, because the glasses absorb some
lightness.<br>
<code>3d-display</code>: convert stereo frames (left and right view side by side) into a
format that can be viewed directly on a 3D display by DTI
(<a href="http://www.dti3d.com/">http://www.dti3d.com/</a>): just play the resulting video with any media player in
fullscreen mode.  The width and height parameters should be set to the
resolution of the 3D display; the default is 1280x1024. The formats are: `<samp><span class="samp">lr</span></samp>' =
left-right (S/S on DTI display), `<samp><span class="samp">tb</span></samp>' = top-bottom (T/B on DTI display), `<samp><span class="samp">ci</span></samp>' =
column-interleaved (Fr/S on DTI display), `<samp><span class="samp">ri</span></samp>' = row-interleaved (F/S on DTI
display). If unsure, try `<samp><span class="samp">tb</span></samp>'.
<pre class="example">     $ cvtool stereoview anaglyph -c -g red-cyan &lt; stereo.pnm &gt; anaglyph.pnm
     $ cvtool stereoview 3d-display -f tb &lt; stereo.pnm &gt; dti-stereo.pnm
</pre>
   <p><a name="index-trackdepth-32"></a>

<h4 class="subsection">2.9.3 trackdepth</h4>

<p><a name="trackdepth"></a>
<code>trackdepth -n|--n=</code><var>n</var><code> -d|--depthmap-list=</code><var>d0</var><code>,</code><var>d1</var><code>,... 
-f|--flow-forward=</code><var>flow-fw</var><code> -F|--flow-backward=</code><var>flow-bw</var>
<var>depthfile0</var> <var>depthfile1</var><code> ...</code>

<p class="noindent">Creates <var>n</var> depth maps by using depth tracking with the given
flow information on the given list of depth maps. The depth
map list contains the numbers of the frames for which a
depth map is available. It must be in ascending order. It is
not necessary to give a depth map for the first and last
frame (0 and <var>n</var>-1), but it may improve the results. Exactly
one depth map file must be given for each entry in the list.<br>
This command uses temporary files that can become quite large.
<pre class="example">     $ cvtool trackdepth -n 26 -d 0,25 -f flow-fw.txt -F flow-bw.txt \
       depth00.pgm depth25.pgm &lt; video.y4m &gt; depth00-25.pgm
</pre>
   <p class="noindent">See also:
     <ul>
<li>TODO
</ul>

<h3 class="section">2.10 Miscellaneous</h3>

<p><a name="index-blend-33"></a>

<h4 class="subsection">2.10.1 blend</h4>

<p><code>blend -s|--source=</code><var>file</var><code> [-a|--alpha=</code><var>file</var><code>] [-S|--single]
[-x|--x=</code><var>x</var><code>] [-y|--y=</code><var>y</var><code>]</code>

<p class="noindent">Blends the source into the image stream, using the alpha
map a. With no alpha map, the source is simply copied into
the images. <var>x</var> and <var>y</var> specify the position that the source
should be copied to. The default is (0,0). Positions outside of
the images are possible: parts of the source that do not fit
into the images will be ignored. When <samp><span class="option">--single</span></samp> is used, only
the first frame of the source will be used; this frame will
be copied into all images of the stream.
<pre class="example">     $ cvtool blend --single -s logo.pnm -a logo-alpha.pgm -x 700 -y 0 \
       &lt; video.y4m &gt; video-with-logo.y4m
</pre>
   <p><a name="index-grid-34"></a>

<h4 class="subsection">2.10.2 grid</h4>

<p><code>grid</code>

<p class="noindent">This command needs to be rewritten.

   <p><a name="index-vectors-35"></a>

<h4 class="subsection">2.10.3 vectors</h4>

<p><code>vectors visualize -t|--type=2i|2|3 [-x|--sample-x=</code><var>x</var><code>]
[-y|--sample-y=</code><var>y</var><code>] [-X|--dist-x=</code><var>dx</var><code>] [-Y|--dist-y=</code><var>dy</var><code>]
[-f|--factor=</code><var>f</var><code>]</code>

<p class="noindent">Reads vector fields in plain text formats, as produced by other commands such
as opticalflow, and visualizes them as a needle diagram. The type of the
vectors must be known; it can be `<samp><span class="samp">2i</span></samp>' for vectors with two integer components,
`<samp><span class="samp">2</span></samp>' for vectors with two floating point components, and `<samp><span class="samp">3</span></samp>' for vectors with
three floating point components.<br>
Every <var>x</var>-th vector in horizontal direction and every <var>y</var>-th vector in vertical
direction will be represented by a needle. The needles will have a distance of
dx pixels in horizontal and dy pixels in vertical direction. The needle length
is the length of the vector after it was scaled with the factor <var>f</var>.<br>
Example: <var>x=y=1</var>, <var>dx=dy=5</var> will result in a needle diagram that is 5 times
wider and higher than the input vector field. Every vector in it is visualized. 
For <var>x=y=5</var>, the needle diagram is as big as the input vector field, but only one
of 25 vectors is visualized. The default is <var>x=y=dx=dy=10</var>, <var>f=1.0</var>.
<pre class="example">     $ cvtool vectors visualize -t 2i &lt; flow-fw.txt &gt; flow-fw.pgm
</pre>
   <div class="node">
<p><hr>
<a name="Examples"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Enhancing-cvtool">Enhancing cvtool</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Commands">Commands</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Examples</h2>

<p><a name="Creating-a-stereoscopic-image-from-a-single-2D-image"></a>

<h3 class="section">3.1 Creating a stereoscopic image from a single 2D image</h3>

<h4 class="subsection">3.1.1 Introduction</h4>

<p>A stereoscopic image is a pair of two images: one right view of a scene and one
left view. When a stereoscopic image is viewed in a way that lets the right eye
see the right view and the left eye the left view, a 3D effect is perceived:
the human visible system can estimate the distance of an object in the scene from
the slightly different position that each object has in the two views.

   <p>Normally, stereoscopic images are created by taking photos from two cameras
that are arranged side by side, like two eyes.  To create a stereoscopic image
from a single 2D image, one has to reverse the distance estimation of the human
visible system: when the distance of an object in the scene is known, its
different positions in the left and right view can be estimated. This process is
called Depth Image Based Rendering (DIBR).

   <p>DIBR uses depth maps are used. A depth map is a graylevel image with the
same dimensions as the original 2D image. For each pixel, it stores the distance
of the corresponding object in the 2D image. Graylevel 0 (black) means "far", and
graylevel 255 (white) means "near".

   <p>If you're lucky, you can record depth maps with a range sensor. All others have to
fake the depth maps. Fortunately, it turns out that the human visible system can
easily be tricked, and that the depth maps do not need to be accurate at all.

<h4 class="subsection">3.1.2 Creating a depth map</h4>

<p><a href="#Figure-nasac000">Figure nasac000</a> shows an image that was taken from a NASA mission video. 
A simplistic depth map for this image was created with the Gimp; it is shown in
figure <a href="#Figure-nasad000">Figure nasad000</a>. It consists of three depth steps ("near", "very near",
"middle") for parts of the shuttle, and a sphere in the "far" range that
represents the earth. This sphere may not be visible in the depth map because of
the dark shades of gray that were used for it. It is probably not necessary anyway.

   <div class="float">
<a name="Figure-nasac000"></a><img src="cvtool-example-nasac000.jpg" alt="cvtool-example-nasac000.jpg">

   <p><strong class="float-caption">Figure 3.1: 2D image "Nasa"</strong></p></div>

   <div class="float">
<a name="Figure-nasad000"></a><img src="cvtool-example-nasad000.jpg" alt="cvtool-example-nasad000.jpg">

   <p><strong class="float-caption">Figure 3.2: Simplistic depth map for 2D image "Nasa"</strong></p></div>

<h4 class="subsection">3.1.3 Depth Image Based Rendering</h4>

<p>For Depth Image Based Rendering, it is assumed that the given 2D image comes from a "middle"
camera. The left and right views of virtual left and right cameras are then computed from this
middle view and the depth map:
<pre class="example">     $ cvtool dibr -d nasad000.pgm -b 8 \
       &lt; nasac000.ppm &gt; nasac000-stereo.ppm
</pre>
   <p>The parameter <var>b</var> specifies the distance between the virtual left and right
cameras, in pixels.

   <p>To compute the left and right view, objects have to be moved to left and right. 
No information is available about the background that becomes visible when
moving a near object.  This causes disocclusion holes in the left and right
view.  These holes are normally filled with a simple average color technique. 
To make them visible, use the option <code>--hole-filling=none</code>.

   <p>Disocclusion holes always degrade the image quality in comparison to the
original middle view.  To reduce the size of these holes, a moderate smoothing
filter is usually applied to the depth maps before depth image based rendering. 
While this further reduces the accuracy of the depth maps, it improves the
viewing experience.
<pre class="example">     $ cvtool smooth gauss -k 3 \
       &lt; nasad000.pgm &gt; nasad000-smoothed.pgm
     $ cvtool dibr -d nasad000-smoothed.pgm -b 8 \
       &lt; nasac000.ppm &gt; nasac000-stereo.ppm
</pre>
   <h4 class="subsection">3.1.4 Viewing the result</h4>

<p>The file <code>nasac000-stereo.ppm</code> now contains the left and right view side by side. 
The <code>stereoview</code> command can be used to prepare this image pair for display on
different devices. Currently, anaglyph glasses (red-blue, red-green, red-cyan) and
autostereoscopic monitors from DTI (<a href="http://www.dti3d.com/">http://www.dti3d.com/</a>) are supported.

   <p>The following command produces a single image that can be viewed with red-cyan anaglyph
glasses:
<pre class="example">     $ cvtool color -g 1.4 &lt; nasac000-stereo.ppm \
       | cvtool stereoview anaglyph -c --glasses red-cyan \
       &gt; nasac000-stereo-redcyan.ppm
</pre>
   <h3 class="section">3.2 Creating a stereoscopic video from a 2D video</h3>

<p>The only difference between creating stereoscopic images, as explained in the
previous section <a href="#Creating-a-stereoscopic-image-from-a-single-2D-image">Creating a stereoscopic image from a single 2D image</a>,
and creating stereoscopic videos is that you have many 2D video frames and need
a depth map for each of them.

   <p>One way to get these depth maps is a camera with a real-time depth sensor, but most
people don't have one of these. Depth data is sometimes available for computer generated
videos. For example, it is possible to modify the Quake3 sources to save depth data
when recording demo videos. See <a href="http://www.marlam.de/Q3-stereoscopic-videos-based-on-depthmaps-HOWTO.txt">http://www.marlam.de/Q3-stereoscopic-videos-based-on-depthmaps-HOWTO.txt</a>
for instructions on this.

<h4 class="subsection">3.2.1 Depth Tracking</h4>

<p>Most of the time, however, the 2D video is all that is available, and manually creating
depth maps for every single frame is not an option. 
In these situations, depth tracking is used: starting from few initial depth maps, the
rest is computed by tracking the depth of objects as they move around in the video scene.

   <p>The requirements for this are:
     <ul>
<li>A video scene that does not change too much, so that most objects can be tracked from the
first to the last frame. 
<li>A motion estimation method
<li>A few initial depth maps
</ul>

   <p>As an example, we use the Nasa video scene
<a href="http://spaceflight.nasa.gov/gallery/video/shuttle/sts-114/qtime/114_fdh05_clip3.mov">http://spaceflight.nasa.gov/gallery/video/shuttle/sts-114/qtime/114_fdh05_clip3.mov</a>
from which the example in the previous section was taken.

   <p>First, we convert the video to YUV4MPEG2 format. Then, we extract frames 800-1250 with the
<code>select</code> command of cvtool. The result is saved to <code>nasa.y4m</code>.

   <p>The motion estimation in both forward and backward direction is done with the commands
<pre class="example">     $ cvtool opticalflow bm-sad    -k 8 -M 5 -D 0.01 -L 0.5 \
       &lt; nasa.y4m &gt; flow-fw.txt
     $ cvtool opticalflow bm-sad -b -k 8 -M 5 -D 0.01 -L 0.5 \
       &lt; nasa.y4m &gt; flow-bw.txt
</pre>
   <p>Beware: this can take up to several hours to compute! Better get some sleep in the meantime.

   <p>Initial depth maps are manually created for the first, middle, and last frame, and saved to
the files <code>nasad000.pgm</code>, <code>nasad225.pgm</code>, and <code>nasad450.pgm</code>. 
The result is shown in <a href="#Figure-nasacd000225450">Figure nasacd000225450</a>.

   <div class="float">
<a name="Figure-nasacd000225450"></a><img src="cvtool-example-nasac000.jpg" alt="cvtool-example-nasac000.jpg"><img src="cvtool-example-nasad000.jpg" alt="cvtool-example-nasad000.jpg">

<p class="noindent"><img src="cvtool-example-nasac225.jpg" alt="cvtool-example-nasac225.jpg"><img src="cvtool-example-nasad225.jpg" alt="cvtool-example-nasad225.jpg">

<p class="noindent"><img src="cvtool-example-nasac450.jpg" alt="cvtool-example-nasac450.jpg"><img src="cvtool-example-nasad450.jpg" alt="cvtool-example-nasad450.jpg">

   <p><strong class="float-caption">Figure 3.3: Frames 0, 225, and 450 of the "Nasa" video scene, and the manually created depth maps.</strong></p></div>

   <p>No we have everything that is necessary for depth tracking. The following
command will produce a series of depth maps for frames 0-450 of the video:
<pre class="example">     $ cvtool trackdepth -n 451 -d 0,225,450 -f flow-fw.txt -F flow-bw.txt \
       nasad000.pgm nasad225.pgm nasad450.pgm &gt; nasad.pgm
</pre>
   <p>If you view the resulting depth maps as a video, you will notice some errors in the tracking
of objects. Nevertheless, the stereoscopic video created with this sloppy depth data will
be OK!

   <p>Now we can use the same commands to produce a stereoscopic video for anaglyph glasses as in the
previous section <a href="#Creating-a-stereoscopic-image-from-a-single-2D-image">Creating a stereoscopic image from a single 2D image</a>:
<pre class="example">     $ cvtool smooth gauss -k 3 \
       &lt; nasad.pgm &gt; nasad-smoothed.pgm
     $ cvtool dibr -d nasad-smoothed.pgm -b 8 \
       &lt; nasa.y4m &gt; nasa-stereo.y4m
     $ cvtool color -g 1.4 &lt; nasa-stereo.y4m \
       | cvtool stereoview anaglyph -c --glasses red-cyan \
       &gt; nasa-stereo-redcyan.y4m
</pre>
   <p>The key to good depth tracking results is good per-pixel motion
estimation, and this is still a very problematic field. You're invited to write
a reliable and fast motion estimator for cvtool!

   <p>The following script summarizes all necessary steps:
<pre class="example"><pre class="verbatim">     #!/usr/bin/env bash
     
     # Downlad the video
     wget -O nasa.mov http://spaceflight.nasa.gov/gallery/video/shuttle/sts-114/qtime/114_fdh05_clip3.mov
     # Convert to YUV4MPEG and extract the example scene
     mkfifo stream.yuv
     mplayer -nosound -noframedrop -vo yuv4mpeg nasa.mov &amp;
     cvtool select 800-1250 &lt; stream.yuv > nasa.y4m
     rm stream.yuv
     
     # Determine the optical flow in both directions
     cvtool opticalflow bm-sad    -k 8 -M 5 -D 0.01 -L 0.5 &lt; nasa.y4m > flow-fw.txt
     cvtool opticalflow bm-sad -b -k 8 -M 5 -D 0.01 -L 0.5 &lt; nasa.y4m > flow-bw.txt
     # Improve the optical flow with a consistency check
     cvtool opticalflow cc -t 1 -f flow-bw.txt &lt; flow-fw.txt > flow-fw-improved.txt
     cvtool opticalflow cc -t 1 -f flow-fw.txt &lt; flow-bw.txt > flow-bw-improved.txt
     
     # Depth tracking
     cvtool trackdepth -n 451 -d 0,225,450 \
     	-f flow-fw-improved.txt -F flow-bw-improved.txt \
     	nasad000.pgm nasad225.pgm nasad450.pgm > nasad.pgm
     
     # Smooth the depth maps for better image quality
     cvtool smooth gauss -k 3 &lt; nasad.pgm > nasad-smoothed.pgm
     
     # Depth image based rendering (DIBR)
     cvtool dibr -d nasad-smoothed.pgm -b 8 &lt; nasa.y4m > nasa-stereo.y4m
     
     # Create a video that can be viewed with red-cyan glasses.
     cvtool color -g 1.4 &lt; nasa-stereo.y4m \
     | cvtool stereoview anaglyph -c --glasses red-cyan \
     | cvtool scale --factor 1.5 \
     | mpeg2enc -f4 -o nasa-stereo-redcyan.mpg
</pre></pre>
   <div class="node">
<p><hr>
<a name="Enhancing-cvtool"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Command-index">Command index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Examples">Examples</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Enhancing cvtool</h2>

<p>Adding new commands to cvtool should be easy. Please look into the subdirectory
<samp><span class="command">cvtool</span></samp> in the source distribution. Every command is in its own file, and
needs only to be registered in <samp><span class="file">cvtool.c</span></samp> and <samp><span class="file">Makefile.am</span></samp>.

   <p>For example, the command <samp><span class="command">foo</span></samp> must be defined in a file <samp><span class="file">cmd_foo.c</span></samp>. 
It must provide two functions: <code>void cmd_foo_print_help(void)</code>, which will be called
when the user types <samp><span class="command">cvtool help foo</span></samp> and should print a short help message,
and <code>int cmd_foo(int argc, char *argv[])</code> which implements the command and
should behave just like the <code>main</code> function of a standalone C program.

   <p>The following macro adds the function declarations to <samp><span class="file">cvtool.c</span></samp>:
<code>COMMAND_DECL(foo)</code>. The following macros adds the function to the list of known
commands: <code>COMMAND(foo)</code>. Both macros should be inserted into the existing lists in
ascending alphabetical order.

   <p>Finally, automake must know about the new file, so <code>cmd_foo.c</code> must be added to
<code>cvtool_SOURCES</code> in Makefile.am.

   <p>Simple existing commands such as <code>cmd_flip.c</code> or <code>cmd_cut.c</code> can serve
as examples on how to use CVL features and the <code>cvtool_getopt()</code> function defined
in <samp><span class="file">option.[ch]</span></samp>.

   <p>Once the new command works, a test script <samp><span class="file">cmd_foo.sh</span></samp> should be added to the
<samp><span class="file">tests</span></samp> subdirectory (look at the existing scripts for examples), and the
complete documentation of the command should be added to <samp><span class="file">doc/cvtool.texi</span></samp>.

<div class="node">
<p><hr>
<a name="Command-index"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Enhancing-cvtool">Enhancing cvtool</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix A Command index</h2>

<ul class="menu">
<li><a accesskey="1" href="#">Command index</a>: </ul>

<ul class="index-cm" compact>
<li><a href="#index-affine-14"><code>affine</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-binarize-22"><code>binarize</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-blend-33"><code>blend</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-channel-23"><code>channel</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-color-24"><code>color</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-combine-4"><code>combine</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-convert-5"><code>convert</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-convolve-21"><code>convolve</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-create-6"><code>create</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-cut-13"><code>cut</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-dibr-30"><code>dibr</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-diff-29"><code>diff</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-edge-27"><code>edge</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-equalize-25"><code>equalize</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-flip-15"><code>flip</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-flop-16"><code>flop</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-foreach-7"><code>foreach</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-grid-34"><code>grid</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-help-1"><code>help</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-info-3"><code>info</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-invert-26"><code>invert</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-merge-8"><code>merge</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-opticalflow-28"><code>opticalflow</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-resize-12"><code>resize</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-reverse-9"><code>reverse</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-rotate-17"><code>rotate</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-scale-18"><code>scale</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-select-10"><code>select</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-shear-19"><code>shear</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-smooth-20"><code>smooth</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-split-11"><code>split</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-stereoview-31"><code>stereoview</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-trackdepth-32"><code>trackdepth</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-vectors-35"><code>vectors</code></a>: <a href="#Commands">Commands</a></li>
<li><a href="#index-version-2"><code>version</code></a>: <a href="#Commands">Commands</a></li>
   </ul></body></html>

